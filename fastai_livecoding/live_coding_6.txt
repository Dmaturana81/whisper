 Okay. Did uh, anybody have any questions or anything from last time or comments or anything else. How's your VM going? I'm only I said one Jeremy I wasn't really sure what happened when I logged so I did the thing and see tags thing in paper space and as per the as per the session and then when I shut down the machine. I'm not sure if you want to go into that. Okay, let's have a look. See if we can. Yeah what might have happened. What happened when you try to use it. I muted myself. So what happened was the member and I had to reinstall member. And, and what else was this and see tags again. And the C tags file had changed, actually didn't have anything in it. Compared to how it was when it was originally created. So, I don't know what happened. But and then when I tried to re index or recreate index and that didn't seem to work either. I mean, one obvious thing we should probably try to get going is being able to see the same. You know, binaries and stuff we install having to reinstall C tags every time is certainly not ideal. Is it? So, let's try and figure out how to do that. All right. Can you see that okay. All right. Let's start this one. This is the one we created the other day. So the only things that. I'm going to still be there next time we come back. Things that are in slash storage. Or things that are in slash notebooks on the exact machine that we just started. And to remind you, there are, you know, we can make this more flexible by taking advantage of the. It's called pre run.sh and the dot BASS RC dot local. Scripts that we can put in slash storage. And we can use those to copy link or move stuff out of those persistent places in into our home directory. If we want to. So that's kind of how we've been. Organizing things. And so when we do pip install with a dash dash local flag, it installs things into our home directory into a sub protocol. Local. And so that we have moved into slash storage and then similar link to back again in our script back to home. So anything that we install with pip install minus minus user will be persistent across all of our sessions. Yeah, can I ask a question about that. So does that mean that if you give you the pass adjusted that you can wipe your mamba directory and use it to reinstall. So the fact that you have the similar to local on the storage drive. Yes, although that thing about wiping was not for paper space because remember on paper space, the mamba stuff is installed into the route directory to the. It'll slash up to whatever it's not in our home to like usual. So you can't really wipe con on on on paper space on on paper space. But yeah, I mean, I don't know why you would, but you could do the same thing on your own machine, you could pip install minus minus user and have a local directory that yeah would be separate from your mamba environments and stuff. Okay, I guess it's smooth. Yeah, I had no. Okay, thanks. That's fine. So I'm just having a look. So, I think the way we, yeah, the way we want to install. Stuff like CTAGs, which is not a Python thing is using. And so we can install with mamba as we've done before. Now, by default, that's going to install it into the, you know, slash up slash etc, which we will lose. But what we can do is. Remember comes with a flag we can use, which is a minus P for prefix. And if we use the minus P flag, it will install stuff into a different directory. And so we should be able to use that to install stuff in a way that we can. That we can reuse it. And I think this is going to be a good exercise in understanding. Paves and aliases and as we're similar, I should say, and all that kind of thing. So I think, yeah, I think this will be an exercise worth doing. So, so I'm just loading up. G put a lab. And so this is the same. Server notebook server that I use last time and since slash notebooks is persistent, that fast AI folder that I that I similarly, that is I didn't seem to get cloned is still there. So if we get a terminal up. And we could probably take a bit of advantage of our space. So. All right. And then apple B or control P be a shows and hides that sidebar, which is quite useful. So what we could do is we could create a so I just type CD, right, which is moving me into my home directory. And so we could create something to put other kind of stuff in here. We'll call it condo. And I believe we could go Mamba. And then say a prefix. So a prefix is going to be our home directories, kind of directory that we just created. Install universal dash syntax. So, okay, so, all right, so we also don't have member installed, which is a good point. So we'd like that to also be permanently available. So let's start by saying. Condor install minus P. Condor minus P install. Mamba. Okay, that's probably going to be after the install command is my guess. Or minus P. Up minus P. Tilda slash Condor. Okay. So while that's going on. Okay, and then because they're not using Mamba forge, that means that the. Condor forge channel is not available by default either. So if you use member forge, then it kind of assumes that you're always going to say that you're always saying minus C condor forge. But since when. And I think the plan is a paper space is going to hopefully switch to using member forge soon. But for now, we'll have to say minus C condor forge. All right. So while that's going on. Let's also get our fast book here. It makes me think about something I just tried to reuse a command that should have been in my history and it wasn't there. And I think the reason it wasn't there is that we are here. Yes, over here. But why is installing Python even. Okay, that's annoying. So, Mamba. Okay, it's say, okay, so it's trying to install it into the tilda slash Condor directory and it's saying, oh, that directory doesn't even have Python in it. So I want to install Python and everything into there. That's annoying. I don't know. Okay, I do have another plan up my sleeve. Which is. There is a version of Mamba that is fully self contained. Everything statically compiled into it. Called micro member, which so we're just experimenting, but here once we get this working, we will. We will make this all easier. So if instead of using member, we say. Slash storage, so we can put this. And where else in a moment. So let's see if that would work. Okay, that's also not working. This is quite tricky, isn't it? So maybe we need to figure out what a minimum environment is because we don't want to use up lots of our storage directory with junk that we don't really need. So what I'm going to do is I'm going to install all this junk and then I'm going to see what that actually installs. And then we'll try to get rid of as much of that junk as possible. That's my plan. I'm not sure if anyone is trying to stop. Yeah, that's roughly what I was getting as well. So, okay, no channels specified. I think I might be getting closer though on this. Condor forge. Okay, that seems to be doing something. So we might be on the way to finding a solution. Okay, let's see what this kind of directory. Wow, it's got a lot of stuff in it. So I want to find I don't want to like have stuff that takes up storage base and I don't need. So the first thing to find out is how much storage base does things take up. So do you use dance for disk usage? It shows you how much storage base things up. So minus S just gives you a summary per directory and H is as usual humanize. So like show me megabytes and stuff like that. So it's easy to read. So this is going to show me the size of every directory. And if I want it for the whole directory. Okay, so I've got 276 meg, which isn't terrible. But let's see, BN is 38 meg. Lib is 203 meg. So it's mainly in lib, right? So what I put to then is go lib slash to see which ones. Now that's quite hard to read. So when things are kind of hard to read like that, I want to find everything that's like over a megabyte or more. So in the terminal, one of the really nice things you can do is you can use the vertical bar called pipe. And what pipe does is it takes the output of the previous command and sends it to another command. And so the thing that you're most likely to pipe to is grep. And grep searches and only prints things that match a pattern. I just want to find those things that are a megabyte or more. So there's a capital M for megabyte. And then there's going to be a space after it. So I just search for an M followed by a space. No, that didn't work. Maybe that's not a space and it's actually a tab. Yes. Okay. So here's all the stuff that's over a megabyte. And we can do the same thing for the directories inside Conda. There they are. So of that 203 meg, it's mainly Python, which I'm sure we're not going to need. So we could. R M minus RF. Python. And. See what else we got here. So we've now got 161 meg, still quite a bit. Still mainly in lib. So let's see if it's a different type of data. So what we could do is just move it out of the way. So that's 71. And maybe just move it out of the way. And then let's see if. Oh, so member. Okay. So we've installed. Sea tags and member, but I can't run them. And all this interesting, I can run the sea tags. Why is that? Oh, okay. So. It looks like. Paper space comes with an old copy of C tags. And this might be the issue. That. You were having with not being able to use it. So normally dash dash version should tell you the version of things. Okay. So my guess is it's not going to work the same way as what we're used to. And that's probably why some people were having problems. So this is not finding the one we just installed and we're not finding member at all. And so to remind you, the reason for this is that the way that we, that the computer finds things to run is it searches in our path. And the stuff that we installed is in the tilde slash, kind of slash bin directory is member. And here's our newer version of sea tags. So we could run things manually by typing bin slash sea tags minus minus version. Okay. So it doesn't need that. Let's move that back in. I see you data. So that needs to go into. Yeah. So here's a current version. Five point nine compiled well two days ago. So, to make it so that we'll be able to see stuff that's in our kind of directory. We need to ensure that it's in the path. So to make sure that things are in the path when we run a bash terminal, we have to put them into our dot vim dot bash RC dot local file. So that's going to be. Okay. So it looks like I don't currently have one. So let's create one dot bash RC dot local. All right. So. This is a file that needs to be run with bash. And what we're going to do is we're going to so export sets of variable. And so the variable we need to set is path. And we want to set it equal to. The conda bin directory. In our home directory. And then we want to also have the contents of the existing path variable. So you have to put dollar path to say the contents of a variable. Okay. So now if we create a new terminal, we can test whether that worked. By printing the contents of dollar path echo was how you print things. Okay. See, so that did not work. Let's try running it manually and see if it works. So source is a way of running a script and storing all the variables in this shell. So if we say slash storage slash dot bash RC dot local. There it is. It's kind of been okay. So why was it not working? Oh, it's not bash RC dot local. It's that bash local. That's why. So we could. Move. So I don't have to type up dot bash RC dot local. I can just type exclamation mark dollar because that means the last token from the last line, which in this case is dot bash RC dot local and move it to bash. Local. Let's try again. There it is. Okay. So now if I run C tags. I've got the right version and I should be at a right. Okay, so I'm going to use Mamba. Okay, so Mamba doesn't like being run. So that's fine. What we can do is we can instead use this micro member thing instead. So let's move. remember into Conda bin. And so you can get micro member micro member. You can download it. I'm here. All right, so let's see how we're doing. Let's get rid of Mamba. And let's see how much space we're now taking up. That's not bad, right? 175 megs. So we've now got a, you know, place that we can install software like CTACs into and it will work. So to make sure that that'll work next time, we now need to move that into our slash storage. And then of course we'll need to sim link it back again. So let's edit our prerun.sh file. Okay, we definitely don't have to remove anything so it won't be there. So we just sim link slash storage slash Conda back to the home directory. Okay. Okay. So there's one other thing I'd like which is my dot bash history file. It's really nice to come in each time and have the same bash history file on a machine in my opinion. So let's move that also into slash storage because that means that our control are and our app arrow and stuff like that are going to always work. So that goes into slash storage. And so let's do that as well. So how am I going to do this in VM? I want to copy two lines and paste them. So to copy two lines, to copy a line is shift y. So to copy two lines, I press to shift y to copy two lines and then shift p to paste those two lines above. Okay. And then I can press shift w to move a word forwards and shift c to change the rest of the line. So that deletes and then it puts it in insert mode and I can type bash underscore history history. Now here's where it gets fun is I want to do exactly the same thing for this line is to replace this the rest of this line with dot bash history. So to repeat myself, I just press dot. Isn't that fun? So all right, let's and that's not a directory. So it doesn't need to be recursive. Okay, so let's try this out, shall we, by spinning up a new machine? I guess I mean, what I mean is spin up an existing machine, do you instance of it? So the reason we're spending quite a bit of time to kind of set up our paper space environment is like, because I think it's good, like practical examples of using bm and using links and using scripts, you know, which hopefully you'll better reuse these ideas lots of times. So let's start that one. Okay, so I'm just going to start up another machine and see if that all works. Okay, well, we wait for it. So yeah, I have a feeling now once you've installed universal CTACs properly and it's in your path, it's just a case of checking the version. So let's create a new shell because that one's and I hit up arrow. Oh, this is still not giving me the right version that's interesting. Add up the shell to the path. It kind of been that's interesting. Conda in CTACs. Oh, okay, it's not sim linked back again because we didn't run that storage script because this is not a new machine. So for now, I'm just going to run the storage script manually. Okay, and okay, still not right. Oh, then the thing that puts it in the path is meant to be the dot bash dot local, right, which should have run. Just create a new shell just to see something weird happened. Okay, so all right, that's in root conda bin. So now for CTACs minus minus version with control R to find it quickly. Okay, it is working. So it's just a case of getting that running it again. Okay, so here's our new machine, which is now finished starting. So let's see if the same thing works on a brand new machine. So, where is this take a long time to start? Open up to put a lab the first time for some reason. On each machine. Here it comes. Okay, so fingers crossed. See tags minus minus version. There it is. And in theory, yeah, we've also got our history. So our history is actually saved between machines, which is quite nice, right? I love it. So if I wanted to echo path again, I could type control R, capital P and it'll find it from my history, even though we're on a totally separate machine. One thing weird is we're getting the path years repeating itself. Not quite sure why that's happening. It doesn't really matter to you, to be honest, but I'm just curious about why slash opt conda, is appearing. But it's not appearing twice. I just use a, oh, no, they're all unique. Don't mind me. Okay, I was imagining things. So on this computer, I don't really want all this stuff in my notebooks either. So let me Rm minus RF everything. That's a really dangerous command. Oh, Hamels here. Hi, Hamel. Yeah, I'm so sorry for being late. I forgot. I didn't even tell people you're coming, so they don't know you're late. So you could have stayed silent and not known. So Hamel hopefully is going to be joining most to all of our sessions from now. So do you want to quickly introduce yourself, Hamel? Yeah, yeah, I'm Hamel. I have, you know, work on fast AI a lot. I especially like contributing to all the dev tools, like NB dev and fast core and stuff like that. And like two other tools that help people automate what people do. So yeah, happy to be here. So Hamels got background as a machine learning researcher and developer and also quite a bit of stuff with MLOps. And also training as a lawyer. So, you know, if anybody needs help with the law, here's the guy. Please don't. That's what the tell people about that, Jeremy. All right. Nice to see you. So we're just setting up our paper space environment, Hamel. And we've got to a point now where I just launched a new instance. And everything is exactly how I want it straight away, which is really nice. We've got a way to install persistently Python modules. We can install persistently binaries. So I think that's a good place to start working through the book because we've got ourselves an environment. So that is step one. Is there anything else that people felt like we're kind of missing from the environment that they would really want? Or should we start working on chapter one of the book? Sounds like we're all happy. Okay, great. I'll stop this machine because that one's costing me money. So here we are in slash notebook. So the first thing we're going to need is we're going to need a copy of the book. So first book is here. So we can copy the SSH GitHub thingy and clone it into slash notebooks. Actually, wait, we're trying to do this properly, right? So if we're going to do it properly, what we should actually do is create our own fork of it so that we can make changes and save it back again. So actually, rather, so what I'm going to do is I'm going to click fork. And that's going to create my own copy in JPHOO. Okay, so let's get rid of that copy in JPHOO. So we can actually do this all from scratch. Okay, so try following along with these steps. Make sure it works for you. So I'm just going to delete my copy of this. JPHOO slash fast book so that we can start from scratch. All right, looks like I need to get my phone. Excuse me. Normally, let's be used GitHub on my phone. All right, I'm just going to do this on my other computer rather than set the soil up. It's a show. First book. The this device option, it was promising to me. This device? Yeah, no, because like, despite DMACC, that like, I don't even have a phone. Normally on my Windows machine, I use Windows Hello to do freeze recognition. And when I say do it on my phone, it's not doing it with the GitHub app on my phone, which is what normally happens. But instead of saying on my phone, I have to install a USB security key. So I don't know. That's right. I can just do it over on my other computer. So delete this repository. And I'm worried about that another time. Okay, on my other computer, I should be able to use my security key. Yes, because it uses fast recognition. Okay, great. My love Windows Hello. It's very handy. Okay, so now that's all done. So right now, great. So now I can. Okay, so now I can create my fork. Whoops. Walk. There we go. So this is going to create a, basically, a copy of the repository. But it's a copy that is linked back to the fastai's version of the repository. So as if, if fastai makes changes, then I can click fetch upstream, it'll copy those changes into our version, which is nice, but it'll also keep our changes as well, as long as they don't conflict. So now, rather than cloning fastai's version, we will clone our version, and we can save those changes back as we need to. Okay, so I'm going to go get clone our fork. You can see here it's got our username and then the repo name. And notice that I'm inside slash notebooks when I do that, which means that now we can see it. And here it is. So let's open chapter one and let's open chapter one and clean. Checking. I remember previously with get clone, you'd done depth of one to not clone the whole repo. Yeah, I wondered about doing that this time, but because we want to probably save, like, commit things back to our fork of the repo, I decided not to go with depth one this time, because we're not just reading it, but we're actually changing it. I have a question. I have never done a fork and an emerge. And I wonder if you can do a sample, just a little test. If that's okay. Yeah, let's make a change and copy it back. So let's just. On the way to the master. Yes, yes, yes. Okay, so let's see if this first cell runs, first of all. You'll see at the very top, there's a pip install fastbook, but it checks. This is a bash line, it starts with exclamation mark, and it's checking whether something called slash content exists. That only exists on coLab. So that'll only run on coLab. So actually it's importing the fastbook and then it's going to import it. Okay, great. And we can try running something. Okay, great. So now let's try pushing that back to our repo. So if we now cd into fastbook. And we do a git status. git status. Oh, good. No, this is going to happen. It changes. Sorry. It looks like you haven't saved that site. Not okay. Yeah, I thought I did, but apparently I didn't. Oh, because it's on a Mac and you have to press command S, and I'm just not used to using a Mac yet. Okay, so it tells us that we've made a change. So to remind you that kind of the shortcut for adding something to a commit and giving it a commit message is git minus a to add it and m to provide a message. And then you need to say what it was you want to do. So I'm going to commit and the message has to be in single quotes. So it knows that's all one string. Test making a change. Okay, ah, so here's another thing that we're going to want to add. To our, um, here's another thing we're going to want to add to our persistent stuff is who am I? Okay, so let's run the things it says to. Okay, and then what you'll find is that there's now a.config file that's appeared here that contains that information. So hopefully you won't be too surprised to hear that what I want to do is move that into slash storage and then vim slash storage prerun and sim link it in our script. Ah, first time around we'll have to do that manually. Okay, and so I rerun the commit by typing control r to search backwards and type commit. Oh, and I'm in the wrong place to get back to where I was is cd hyphen. There we go. Okay, so that's committed it to my local version of the git repository. So if I control our status, you can see that I don't have anything left to commit, but it does say that your branch is ahead of master. So that means that I haven't pushed it back to the server. So git push will push it back to the server. There we go. So if I now go back to github, you'll see that this branch is one commit ahead of faster your master. So I've made a commit that isn't part of fast. So, you know, by the way, sometimes, so like, a lot of the time you create a fork and you make changes because you just want to make changes to your version. Sometimes you make a fork and make changes because you actually want to provide those changes back to the original project. You know, you fixed a bug of theirs or added a feature of theirs. And so if I wanted to send my changes back to fast.ai, because I think they're an improvement to the book, then I can say contribute, right? And then that'll say, oh, okay, you can create something called a pull request. And so the pull request, it's going to show you the changes, which is I've executed some cells I hadn't executed before. And I've added a cell where the source was one plus one and the result was two. And then I could create a pull request and that would send something back up to fast.ai and I'll show you what that would look like. Obviously never do this unless you assure you want to because that's just going to annoy the developers. So then what happens is that would appear on my copy of fast book. It would appear in pull requests. And so here's an example. So when you send in a pull request, I'll then be able to see what files you changed. Using this thing called review and be, I'll even be able to see the changes that were made to the notebooks in a graphical view. So I'll show you what that looks like. So there we go. Questions added these cells. And they've provided a description. And so then if I wanted to add this back to fast.ai, I go click this button. So that's what people talk about when they talk about making a pull request. Anyway, that's not quite what we're doing. We're just keeping our own copy of it as we discussed. All right. And can we have a version of review in the local machine? Yeah, absolutely. Review and be is a startup. They're very, very good. You can absolutely so you can totally add it to your own repos, just by going to review and be calm. No, I mean in my local machine. No, but you can use something quite similar called and be dime. Which is actually so it doesn't really make sense to like have it on a local machine because like you don't pull request to yourself on your machine. But what you do want us to be able to see is to see differences. And so for example, with mine because I've got nbdive installed. If I let's make a change. So let's delete this cell. Save it. And so it's nbdimes already installed on paper space. So I can click here and I can see, okay, I've made this change as I've deleted one cell. All right, so let's try running. Oh, something's happening. Okay. While this is running, let's talk about what's happening here. So the first thing we've got here is a from blah import blah statement. So let's understand what's happening here. And to do that, let's cd into the fast AI repo. Okay, so here's the fast AI repo. And the fast AI repo contains a folder called fast AI. And that contains the fast AI library. And in the fast AI library, there are some also as well as some Python files, there's some sub folders. Now in this case, we were importing stuff from fast AI.vision. And that tells us that there must be a directory called vision. And there is indeed, here's a directory called vision. cd fast AI slash vision. Right. And then in there, finally, we're importing from a module called all. And that means that there must be a directory called all sorry, a file called all dot pi. And here it is all dot pi. So what happens when we say from blah import blah is it goes through all the dot separated components except for the last one and treats these as directories. Right. And so basically what it's doing is it's going to look for a file called called fast AI slash vision slash all dot pi. That's how it gets translated. It's all very mechanical. You know, there's nothing magical weird about it. And so then if we look at that file, here it is. Right. And what does this file do? Well, this file is just importing things. And so it's importing something from models, basics, blah blah blah. Now, when you're inside a library like this, you'll see sometimes it uses dot or dot dot prefixes. That's going to be replaced with a file called dot dot slash basics dot pi. This will be replaced with a file called dot slash augment dot pi. So we should be able to find if I go control split control sp a ug tab. Yep, there is indeed a augment. So I've just got a split pane here. Here's my augment file. And so when it goes from dot augment import star, what does that do? If there's a special variable called done to all, this when you've got underscore underscore blah underscore underscore, we pronounce that done to blah. So this is done to all. If there's a special variable called done to all, that's a list of all of the symbols that it wants to bring in. Right. And so here's a list of all the symbols it wants to bring in. So this file, this command here will bring in, for example, a symbol called round transform into this file. Now, this file doesn't have something called done to all. And so if you don't have a file called done to all, then every single thing that is imported or defined in this file will end up being exported from it. So since this line here imports something called round transform and there's no done to all here, that means importing all dot pi should also import round transform. And so that means I should be able to type round t tab. And there it is. There is a round transform. And if I hit shift enter, you can see where it's come from. So it's come from fast.ai.vision.org. dot round transform, which remember is translated to fast.ai slash vision slash augments slash. Sorry. Okay. This is actually the name of a method. So this will become fast.ai.vision. Fast.ai slash vision slash augment dot pi. And then we'll find the round transform class or symbol inside there. And so let's find it. So if I click on round transform, I'll show you a really nifty trick. If you select something in VIM and hit the asterisk key, shift eight, it will search for the next place that this word occurs. So if I press star asterisk, here's the next copy of round transform. And so here's the definition of it. So that's what it does when you say from blah, import, blah. If you say import star, then that will import everything that's exported. So everything in done to all, or if there's no done to all, everything that's defined or imported. So that's why we now have a thing called round transform available to us. Yeah. If you ever want to know where something's from, a lot of people are used to not using a wildcard import, so not using star, but instead listing specifically exactly all the symbols they import. And so somebody does that. You can scroll back to the top of the file and search through it and try to find it. But you don't have to. It's much easier than a deed with star necessary to simply type in and press shift enter, and you can find out where it's from. Want to get more info about it through the same thing with the question mark. And as you can see, it will give you the signature, the doc string, and the full path name of where it's from. And so this is one way if you want to go and look at the source code for this, is I could copy that and type colon sp and paste it. And now I've got a third split and here's the file. But if I just want the source code for that one thing, I can just put two question marks. And as you can see, this gives me the source code for that thing. Okay. So that's what the first line does, first AI vision all imports. What does the next line do? So if I type doc on data in a first AI library, it'll tell me what this one didn't quite work correctly somehow. It'll tell me all the information about it. For some reason, this one's not getting the usual documentation. I would expect to see that's okay. You can always click on source to get a link to where it's defined. So here it is, on hard data. Or you can click on show in docs. Oh, this one works correctly. That's interesting. So for some reason, the help the doc commands not working right. I'll fix that. Yeah. So you can see here's the details here. And you can see that there's, you know, it says here, for example, C URLs, you can click on these things to get more information about them. So there's lots of sim links, as you can see within the documentation. So untired data downloads and extracts URL by default into subdirectories of tilde slash dot plus.io. So we now know that means you're your home directory and it returns a path. Okay, so let's see if we can understand what this is doing. So what I generally like to do to understand a cell is to run every single line separately. So the most important thing to know how to run every single line separately is to know that you can press control shift hyphen. It's control even on a Mac, not command control shift hyphen to split. It's going to get into two cells at the cursor. The step one is to separate this out into separate cells. Okay. And so then, you know, run each one and see what happens. So after I run this one, I should be able to look at path. Okay, so it tells me here that it's been stored in slash storage slash data, slash, etc. Now that's good news because we know that means it's persistent. So if I create a new instance, whatever, I'm going to have this same thing. Now downside is if you have a free or cheap account, you don't have much space and you might not want all that space being taken up. So let's find out how much space is being taken up. So let's copy that, head up over to our terminal, get over there. And so remember we can type du minus SH dot 789x. So that's pretty big. So you might not want that to be there, which is fine. So you can just move it somewhere else, you know, put it in the home directory or something like that. So one interesting question is here is like, according to the documentation, it was going to extract things by default to sub directories of tilde slash dot fastai, but that's not what happened. Why is that not how it happened? Well, it says it's a wrapper around fast download dot get. So we should probably look up that documentation to find out what's going on. So here's fast download and here's fast download dot get. Okay, so this is pretty much what we saw. Rather than, you know, this is using d.get, it returns a path by default. It goes into base archive, which by default is, in this case, dot fast download for fastai might change it to fastai. You can change them by passing fast download. Okay. Oh, look at this. If there's a config file in the base directory, then they will be used for fast download. Now our base directory for fastai is dot fastai. So let's go and have a look in the dot fastai directory. That cd tilde slash dot fastai. There we go. There is indeed a config dot any. Ah, so you can see that paper space has actually set things up for us. So that by default, all of the archives, models we create, data we download is all going to be put in the persistent storage. So that's like, that's a good thing. Unless it's not what you want. Right. So I would say this is another of these things that we probably want to be able to adjust if we want to. So how about we move that into slash storage. And then as per usual, dim link it back. So when we start the machine, I don't know if there's a dot fastai folder there or not. So what we can do is we can say, a make down bonus P basically creates a folder and all of its subfolders, sorry, all its parent folders and doesn't complain if it's not already there. So I use make down as P to create a dot fastai. And we will then remove a. Dot fastai. Oh, now I'll show you a little trick. I want to fill out the word fastai with that type in the whole thing. If I hit control P, it will fill in the rest of the word P for previous, it will fill in the rest of the last word that it confined. It starts with those letters. So I want to remove fastai slash config. Dot any. And then we will link that back again. So it's going to be in slash storage. So I hit control P that's less storage and it's going to be called config.any. So I press control P and actually if you then hit control X, control P, it keeps filling in the rest. All right, so now we're going to have config any file. Oh, except I don't want to put it in the home directory. I want to put it in the dot fastai directory. And so we can test that. Copy it. Paste it. There we go. Okay, so we've now got a consistent config.any. I think in my case, what I want to do, and this might not be bad for most people, is I probably don't want the archives to be stored in my storage directory because I'm not going to need them again once it's been unarchived. And so let's cd to slash storage slash archive. Yeah, I don't want this there. So let's just remove it. Cool. Okay, so this is now going to put by default stuff that I download will be in my storage. I'll be able to use it anywhere, but I can always move it somewhere else if I want to. Okay, the next two lines kind of go together, which is I'm going to use image data letters. So again, you know, before you use something, it's good to understand what it is. So so Show in docs. All right, image data loaders is a wrapper around several data loaders, with methods for computer vision problems. And what you're going to be using is one of the factory methods, so there are things underneath and all these factory methods accept various things. So this tells me that there are various different ways of creating image data loaders, and they've got a consistent API. So that's good. In our case, we've got, if I hit shift tab, I can find out what the parameters are. So I've got the path. I've got a list of file names. I've got a labeling, let's see, oh, then I've got valid percent and seed. So valid percent and seed. So what do those mean? Are we using from name, valid percent is passed to image data loaders from path. Okay, so quite often, you know, we'll take a argument and just pass it to something else. So I have to click on here to find out what that does. Here we have validation set. Validation set is a random subset of size validation percent. Okay, no worries, optionally created with seed for reproducibility. Cool. And it's got a labeling function. So... So... Oh, wait. From name function. A function that receives a string, which is a file name and outputs a label. Okay, so let's just have a look at some of these things. So the list of file names, so remember the second argument with a list of file names is this. So let's pull this out and create something called files. So if I press A for append above, I'll type files equals pasted here. Okay, and let's look at that. Okay, so files is a list of 7,390 items and it contains various paths in it. Now I'm going to mine myself. If you go path.base or base path, I'll show you what I'm doing in the tick. Let's get rid of all this prefix copy and paste. There we go. Yeah, so if you create a special variable called path.base.path, then it will delete that from the start of everything it prints out. So it just shows you the relative to here. It's a bit easier to read. So the 7,390 things with images slash blah, images slash blah. And it looks like it's going to be the name of the breed. And then an underscore and then some consecutive number. Now this looks a little bit different to what you might be used to seeing. Normally, if you look at something like a list, you expect it to look something more like this. This is what lists look like in Python. So to find out why that looks different, we can check out what the type of it is by typing type. And it turns out it's not a list. It's something of type capital L. That's a special kind of list, which has lots of convenience functions in it. We could just use question mark to find out a bit more about it. So here's the definition of where it's coming from. Here's the doc string from it. Or we could type help L and not help doc. So help is useful as well. That's a built into Python. It shows you a list of all the stuff it can do. Actually, maybe that's useful. So as you can see, it's got lots of functionality in addition to everything that a list does. Or we could type doc. So you can see this stuff's not just for fast AI libraries. It's for all libraries created by fast.ai look pretty similar. And so here's lots of information about L. Let's learn how to read this documentation. And then I think we'll stop. So L is like a list. Okay, so a list in Python is something that you create like this. Square brackets. And you can print them, for example, or you can index into them. Or you can select multiple things from them. Everything up to, but not including element two. That's a list. Okay, and L is very similar. But it doesn't have any special syntax like Python does. You have to create it like this. But it basically looks much the same. As you can see. But it has quite a lot more functionality than a list. So I don't use a normal Python list that often. Because like, why use something which is less useful. So let's see. Okay, there is like a list. So you know what a list looks like. So drop in replacement for a list. So when something's described as a drop in replacement, anywhere that uses a list, you should be able to use this as well. So it's got a super set of the functionality. It's like NumPy. It supports advanced indexing. Okay, so what that means is that you should be able to select multiple things from a list at once. I'm just trying to remember exactly how we do that. I think you can go like this. Yes, okay, so I can select the zero thing and the second thing and one go. So that's an example. And as it mentioned, this is similar to what NumPy can do. So NumPy has a thing called an array. And so in NumPy, you can do the same kind of thing. But a regular list, remember, a is our regular list. Can't do that. So you can kind of think of a capital L object as being a bit like a hybrid between a NumPy array and a Python list. You could try to use a NumPy array for things that you would otherwise use an L for. But the problem is that a NumPy array kind of expects everything to be of the same type. So you have to be a bit careful. Sometimes it might do it for us. No, sometimes it can actually handle it for us. It's going to put them into something called an object. So, you know, I mean, actually, no, I think about it. You probably could use an array quite often, but they do behave differently. Actually, I'll show an example. So if we go B plus below, then that's what that does in an L. It adds hello to the list. So notice that Ls show you how many items are in it. And it also by default doesn't show you all of them, but it puts dot dot dot, which is both very convenient things. A Python list. Oops, I used control by mistake. Works the same way. An NumPy array doesn't work the same way. And that's because NumPy is designed mainly for math. So if we make all of these into numbers, then a NumPy array, we could do this. It adds element wise. Okay, so, you know, if you're kind of trying to go deep and fully understand each line of code, this is a kind of experimentation that you can do. And hopefully what you can see here is that all of the information you need to fully understand all of these things is available to you in the documentation, which you can link to directly using the dot command and by experimenting. But it is like, initially, it's a lot to learn. But the nice thing is that the things you're learning are very reusable, right, because all this stuff is used all over the place. All right, so I'm going to wrap it up. Does anybody have any questions or comments? It's been a bit less interactive than usual. So I apologize if that's because I'm talking too much, but I definitely want to hear your thoughts or questions. Nothing? That's fine. Thank you. Is that because it's too easy or too hard or totally obvious or I want to go away and think about it. For me, it was very good, Jeremy. Okay, great. No, I think it was perfect for me. Oh, awesome. Cool, Jess. Okay. I haven't seen somebody called Jess in a stream before. Are you a new person here or who does not notice you? A new old person who just saw it pop up in the forum. Awesome. That's like how did it not pop up for me sooner? Thank you for joining Jess. Where are you joining us from? I am in the Seattle area of USA. Fantastic. Great. I think, yeah, okay, well, that's a good time to finish. So I hope to see you all tomorrow. Great. Awesome. See everybody. Bye, everyone. Okay, thank you.
