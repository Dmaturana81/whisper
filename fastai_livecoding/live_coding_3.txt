 All right. Does anybody have anything? Yeah, they wanted to ask about or talk about or anything else before I had a quick question. Yeah, I was quick. When we're talking yesterday and I asked you about the environments, you seem to feel very strongly that you should work in the base environment and I've been rolling it over in my head. And I'm just when I think about the mistakes that I've made and how I've screwed up environments and gotten conflicts and stuff like that. I was wondering why you feel so strongly about that. Sure. I mean, we'll talk about it more when we kind of get to environments, but because we haven't discussed them yet, but you know, briefly, you know, environments are basically separate folders with separate installations of Python and Python libraries and so forth. They're often used for kind of keeping separate projects separated with different sets of kind of dependencies or versions of Python or whatever. And they certainly have a role to play for advanced users. I almost never use them. I mean, very, very occasionally use them. But my feeling is the most important thing is to be able to rapidly iterate and experiment. And I kind of want my projects to live together as a as a whole as a bunch of things which all help each other and come together. So I don't like the idea of like, oh, I'm working on this project now. I go over there and everything's kind of new, you know. So instead, I really like to get very fast and very good at just quickly just going RM minus RF mini forge and it's gone and run setup Conda dot SH and it's back and have a single script that if I need one, it don't mean I don't even need a script on a scale member install minus C first Chan fast book, and that installs everything that I need. And I'll go. So I kind of like never want to be in a situation where anything on my computer is I don't really like it's working, but I don't know how I got to a point that it's working and I don't want to touch anything less I undo that, you know. So I'm more in the kind of chaos monkey side of like, explode things from time to time intentionally and be really good at putting them back to where they were, I guess. And yeah, so nowadays I never have problems basically with dependencies or weird things going on in Python or whatever, because I just, you know, like probably every few weeks I'll just throw it away and clean install it just to try something out for teaching or whatever. I always feel fine. You know, this morning, I did use an environment because I specifically wanted to test something on a different version of Python. And I wanted to check that it would install into somebody's fresh new environment. And so I, I used it for that. I think it's useful if you are like, installing some library where they've done a poor job of keeping their dependencies up to date. So you need like Python 3.6 and sentence P one point eight, and I don't know old versions of things, in which case you want to be able to go pit minus our requirements dot text and get all these exact versions of things. But my approach is to, for my projects is to not pin versions, not pin dependencies. I want to be but I want anybody to be able to install my work into whatever they're doing and work with all their other programs that they're running and libraries that they're using without anything getting messed up. Unfortunately, not everybody works that way. But that's how I, you know, try to make other people's life easier. And so therefore, any programs you use from me, you'll be able to install into your base environment without messing anything up or install into any environment without messing things up. And when sorry, just a quick follow up. If you're installing, if you're installing into like a new computer or whatever, would you install fast book or would you install fast AI? You know, I would, it depends. I would just probably install fast book, because fast book installs fast AI, which installs NumPy pandas with a map plot lib. Also installs transformers, it also installs data sets, it also installs sentence piece, you know, maybe it doesn't install a sentence piece. I think everything accepts sentence piece. There's no reason it shouldn't install sentence piece. So it didn't yesterday. Yeah, just remembering that. So Jeremy, yeah. So if you're blowing, blowing it away and you're basically using a new OS installers as like people do with environments, what, how are you keeping track of your things like RSA keys, etc. How are you not blowing those away? Those are not part of a country environment. So that's, that's fine. They sit there in my home directory. It's just that many forge directory or many cons directory or anaconda directory, depending on what you're using. I just delete that. Cool. You talked about uninstalling always, right? In this base environment. So yesterday I was trying to, I messed up one of the dependencies. So what are the steps for running this joining? Usually I know that I just go to your home directory and type RM minus RF member forge. Only that is required. Okay. I then close your terminal and reopen it because I remember the other day, she didn't do that step. And so I didn't install properly. Yeah. Let me show you a quick trick. Yeah. So this is sorry. This is a little more advanced than normal, but that's, that's okay. So the, the, this is slightly confusing, but the fast book pipi and condo installer actually comes from a repo called course 20. And it's here. It doesn't really contain any code. It contains a few utils, but that's actually like search images being, but you know, this has got nothing to do with what we're using it for. Or something that returns an image of a cat. But actually the key thing is it's got a settings.any file, which contains a list of requirements. And so if I now put this up on pi pi and condo, then if I say condo install or pip install fast book, then that's one quick way of just getting all these. Or you could create a tiny little script that goes, you know, condo install. And then with these things in it. But yeah, you want some way to get yourself into the basics set up instantly. Oh, here we are. This is why I didn't give me sentence piece. Sentence piece only comes with pip. And that's because when I set this up, I didn't have fast Chan. And so I didn't have sentence piece in condo. So I mean, Jeremy, I think you've got a you've got minimum Python there 3.6. But I think fast AI repo has 3.7 in. Yeah, yeah. Which I suspect it probably overrides. But yeah, so here's a good physical use of the the GitHub GUI. Right. I want to just change it while I'm looking at it. And we're done. Cool. Yeah. Okay. So that was a good question. And, you know, we'll, at some point, I'm sure we'll need to create an environment for something and we'll talk more about that. I guess like maybe something else just, well, we're here since we are, as I said, this is a bit more advanced and people can totally skip this. But just, I mean, it's probably worth understanding what Conda slash member is and how it works. Right. So remember the other day I typed which Python. And I saw that I'm getting that Python is coming from this directory. So like one obvious question is, well, how does why is it coming from this directory? And the reason why it's coming from this directory is, let me just open up this a bit more so I can see my people. There we go. Is that Linux, I mean, I shouldn't say Linux, you know, bash and pretty much all shells. They use the concept of something called the path. And the path is the list of places to look for programs to run. And the path lives in something called an environment variable and an environment variable is just like a Python variable, but it's a variable that lives in your shell. And you can, you can print them out. So that instead of print in your shell, you type echo. And then an environment variable, you know, normally if I just say echo something, it just prints it. Right. So if I want to echo the contents of an environment variable, I have to put dollar before it dollar means this is a variable that I'm printing. And so the variable path, there it is. Right. And so you can see that this is a string as colon separated string. And in my colon separated string, there's something which is home, jhow, at member forge, bin. And so that directory, if we take a look at it, it contains lots of programs. And one of those programs is pi, Python. Okay. So that's, that's why it is when I type Python that, that, I'm sorry, I didn't mean to do that. When I type Python, that's the Python that it runs. So here's a little trick. I want to type which Python, and I'm so lazy, I couldn't have even be bothered typing Python. So if you remember, double, double exclamation mark means the previous command. So that's going to be which Python. So it's worth looking and seeing like, well, what is this member forge directory? So the member forge directory, for those of you that are kind of seen Unix type directories before, it, it contains a bin directory and an etc. directory and a lib directory. And this basically looks very similar to my, to my Ubuntu's root directory. And so basically, you know, a Condor or member forge or whatever, root directory is kind of a copy of a Linux or even actually a Mac root directory, contains very similar things, etc. User, so forth. And what happens is that the thing that it puts into our bash RC, so remember our dot bash RC is the script that automatically gets run this thing here. Basically, this is a little, it runs a little shell script that sets some environment variables. And one of the environment variables that sets, for example, is the path environment variable, and it adds this to path. And it does similar, something similar to kind of make all the libraries work as well. And so we mentioned how you can create a totally separate, you know, environment, a totally separate place you can work that has its own copy of Python and libraries and stuff. The way you do that is you go mamba create minus n, give it a name, and then say, what do you want to have in it? So let's say, okay, I want to have Python in it. I don't normally like to have, I don't normally like to have the latest Python, so let's get something before 3.10. And I also want fast work in it. So that's going to create, so you can go mamba create or conda create. Actually, you already have that because I used it this morning, as I mentioned, so I'll remove that automatically and create a new one. And so that's going to set up a new environment, which we will take a look at. So currently, what it's doing is it's downloading from the Internet a list of all of the conda packages that are available from a channel called CondaForge, which is the main channel that mamba forge uses. And it says, okay, I'm going to install Python and fast core to install those things. I'm going to need these other things as well. That sounds fine. You'll see it's cached. So basically, one of the nice things about mamba and conda is that it kind of saves the archives that you've downloaded. It doesn't have to redownload them. So as it now says, you can activate this environment by typing mamba activate term, or conda activate temp. So that's changed my shell. If I now say which Python, it's getting it from a new place, and it's getting it from the same places before, home j how with mamba forge, but it's now getting it from m's temp. And that's because this mamba forge directory has a directory called n's. And that m's directory is a folder that contains each of those environments. And it's really interesting to see what's in them. Because look, it's yet another copy of the kind of things you would see in the root of a Linux installation. So that's that's why it works, right? It's basically yet another copy. So for example, we'll see that in m's temp bin. Here's another copy of Python. So if I type Python, it's running that Python, and it's got its own set of libraries. So it's using those libraries. So it's yeah, it's really neat. And you can install compilers, you can install, you know, any binaries you like, you can install Rust, you know, separate copy of Jupiter, whatever. You know, by the way, something that's quite neat, not as important as it used to be, but these are actually using something called hard links to to create these. So they're actually not even separate copies. So it's like not even using disk space. So yeah, the whole thing is really quite nifty. So yeah, so basically, when you go activate, it's in fact, let's take a look at my path. It changes my path. See, so now this comes first. Look at hard links. So I find hard links quite useful for myself. When I have a lot of data in a folder, and I want to run something on this data from another place, I just create the hard link. You create some links or hard links, because normally you'd use symbols for that. Yes, that's the word. That's the wrong question. I create some links. Yeah, yeah, we will get to some links. Let's wait until we kind of need them, maybe. Okay, so to go back to activating the base directory, I just take contact to activate. Now I'm back in my own site, main environment. So yeah, hopefully that explains a little bit about what environments and why you might use them. There's a certain way of developing software, which is particularly common in the JavaScript world, where you freeze the exact versions of everything at a particular point in time. And so you end up with things like, you know, well, in the Ruby world, you end up with a gem.block file in the Python world, you end up with a requirements.text file in the JavaScript world, you end up with your packages.json file. This is something that I would strongly recommend trying to avoid as a data scientist when you freeze particular version numbers. It makes it almost impossible to mix and match things from different places, you know, this library from here and this thing from here. You end up going into this huge, complex ecosystem of Docker containers and, you know, trying to find ways to make that all work as can get quite overwhelming. And you can actually, you can actually entirely avoid it by just, you know, using a single base environment and keeping your libraries up to date and having good tests and knowing when a release has broken something and so forth. You know, this is not always the way, but this is my suggestion for, you know, rapid iteration data science is to do things this particular way. All right, so then we've got our own computer running. And it's nice to be able to use Python on your own computer because, you know, you can rip it out a laptop anywhere, don't have to be on the internet, you don't have to start a server somewhere, it's, you know, it's nice to be able to quickly play with things. And, you know, I think, like, ideally, a large amount of the time you're not using the GPU because a large amount of the time, hopefully, you're like exploring results or you're testing out things and really small samples that don't need a GPU or, you know, hopefully you can do a lot of stuff on your computer. At some point, you need a GPU. And my view is that you should try to use a GPU in a way that feels as much like your computer as possible, but doesn't cost you much, if any money. So, at the moment, my view is by far the best option for that is, paper space, paper space is actually a company that have a few different products and specifically it's a product called Gradient. Gradient is, in fact, specifically, it's Gradient Notebooks, let's keep going to you by Gradient Notebooks. So, Gradient Notebooks is basically something where you can get a free GPU server, which behaves a lot like what we've just been working with, you know, you'll get a terminal and all that stuff. So, let me sign in. Okay, so paper space has this concept of projects. I have no idea what they're useful for. I just have one project, so I'll just go ahead and click on it. They're just they're the things that contain your they call them notebooks, but these are basically servers. These are some servers. Now, I there's a few options for like paying their money. And if you can afford it, you know, this is such a good deal, the eight dollars a month, not only because as you'll see, you get some pretty good GPU options and you can keep things private, but you also get more persistent storage. So that means you can store things between sessions. Now, the reason this is really important is because these aren't actually my servers that paper space has not put aside servers to me to use. These are kind of small little saved snapshots, basically. And it's got to kind of create a new computer each time I fire one of these up. And so it's really nice that as you go from instance to instance, to be able to access the same files each time. So let's start from scratch because that's what we're doing. Okay, so it says select a runtime. Basically, what this is going to do is it's just going to pre populate your server with some files. And so if you choose the first AI one, then you'll have the main stuff, you know, basically everything you need for the book pre installed. So let's do that. And so as you can see, there's various three options and various paid options. So I'll use there. So basically, you know, important things to know about is how many, how big is the GPU? These are all pretty good. Eight or 16 is great. Sixteen is obviously better. And then how fast is it? P that that'll probably be a Pascal card. So that's a couple of generations old. So it's like quite a lot slower than modern cards. RTX is totally up to date card. But this one's got a lot more GPU. So I'm just going to pick this one. Six hours. So it's going to, you know, if you're paying for it, make sure you've got all the shutdown set to something sane. Otherwise, you'll end up paying for it for a long time. You can easily share notebooks with other people by turning public access on, which is by default. There's a few advanced options here. I don't think we particularly need to touch them, to be honest. One thing I'm just going to note now is that it's going to run a command called run.sh. So we'll just note that down because we're going to check it out later. And you'll also see it's actually going to clone a git repo. So, I mean, one thing you could do is if you've got a fork of fast book, then replace fast AI with your username and you're going to get your forked version. Okay, so I'll start. So, yeah, so I don't know. I find it's a bit confusing that it says start notebook. It's not a notebook, right? It's starting a server for us. And that server is going to run a duperton notebook automatically. So the thing that appears here is the paper space GUI. I don't love it, honestly. So I don't really use it very much. The one thing that you do particularly want it for though is to be able to stop your server when you're finished, especially if you're paying for it. But I mean, you should do it anyway, because there's no points using their server hours. So what I'm going to do is I'm going to just copy this URL and create a second tab and paste it just so that I've got two versions of that. So this one here is just going to be sitting here and I can go back to it and click stop later. In fact, when I close this tab, it'll remind me that I have to click stop. So this is a good way to not accidentally forget to stop your server. Yeah, that auto shutdown. It happens if you're inactive, or that would shut down regardless. Just shut down regardless. Yeah. Yeah. So that because they don't really know if you're doing things that don't really have any telemetry or anything. Oh, by the way, this five hours seems to be truncated down. So it's actually five point nine hours. That's just something I noticed. It's a bit of a bug, I guess. Yeah. So in five hours time, it's going to shut down. You have five and, you know, hours and fifty five minutes time. It's going to shut down regardless. So the first thing I do actually is I click this button, which gives us proper jubilant lab. And then I don't have to use their slightly crummy GUI anymore. And this is also nice because now we're going to be using something that's just like what we have on our computer, which is the goal. Okay. So here's jubilant lab. And you can see that the book is here. And yeah, this is basically the get repo that we, that was automatically filled in for us has been cloned into here. Okay. Just what I'm going to do is start a copy of an old machine as well. Not great. What am I doing? Gradient. Because I want to access some files from there. Start machine. Okay. So, um, let's, I mean, so I guess to start with, we could go into clean, open up MNIST basics. So let's see how much they've got installed, see if it's all ready to go. Let's try running this cell. Well, there we go. It looks like it's got everything else. Try running this cell. Nice. Okay. So it's basically got fast book installed and sentence based installed. So that's good. So you, we checking to be the level of checking the paper space. We are in paper space right now, see? I'll just remind you, I expect on this button. And that gives us jubilant lab in paper space. Thank you. So, no problem. No, no problem. It's easy to miss things. Ask any time. So one thing that is actually, I find kind of confusing about Jupyter lab is it has its own set of tabs in its own interface and it kind of replicates things like that could be in a browser. So in a lot of ways, I kind of prefer the older version of Jupyter, Jupyter classic, which you can always switch to. But you know, you can get used to it. And one thing that helps a lot is if you just full screen this, right, and kind of know the keyboard shortcuts. So control shift left and right square brackets switch between tabs. And that's the main one to know. And control B turns on and off the sidebar. So this way, at least you can like get a nice, you know, gorgeous if the screen, particularly when I click terminal. So if I click terminal here, that's not bad, right? I've got plenty of room to see my terminal. So that's nice. Okay. So I don't. Oh, Jeremy, just on the bottom there, if you want to get rid of those tabs for any reason, there's that little switch that says simple. Yeah, they'll hide those tabs. Yeah, that actually gets rid of the tabs as well, which I'm actually using the tabs. But what you can do is you can go remove status bar, it gets you a bit more room as well. So yeah, now we've actually doing pretty well. And one particularly nice thing in Jupyter, by the way, is it actually has a graphical debugger, which, you know, so if we go for in range 10 print, I, and then we turn on the debugger with this little button here. And so we can turn this, we can put a break point here on and off by just clicking. And so now if I run this cell, you'll see that it's got a break point, which is very nice. And we can. Got a lot of things in here, doesn't it? Why is that? There we go. Music. What? Let's get that one. Okay, so you can see like, here's I, and so if I now step through this, let's be a better way to just show what we want. Okay, so it's kind of like, yeah, it's, it's, that's kind of a useful thing to have, I think. Yeah, I guess this would probably be easier if this is actually probably a really good place to not use import star because I don't see an obvious way to only add variables we want to the debugger. So let's restart the kernel. Turn on the debugger. Okay, and then run this cell. There we go, that's much better. So now we can just see that variable changing. You might be wondering why it is that I clearly am not very competent using the graphical debugger, and that's because I don't use it myself because I actually really like the, the non graphical debugger, which I'll quickly show you, the non graphical debugger, you can use anywhere. Jupyter doesn't have to be a terminal or whatever, but inside Jupyter, if you just put percent, percent debug at the top of your cell, it runs the regular Python debugger, which is a, it's a REPL, a reboot of our print loop based debugger. And you can type h for help to find out what you can do. And basically, you can type just the first letter of any of these if they're unique by first letter. You can see actually the ones which have the first letter. So C is short for continue, h is short for help, and is short for next, p is short for print. So the single letter ones are short for like the ones that you use all the time. And I always use the single letters because, you know, I wouldn't you. So for example, L, actually, I'm not really in a file. So that won't work. So let's try, for example, we can do n for next. So that just n goes to the next line. So here we are. So we've now gone into the, you know, the code that we have in our cell. So we should now be able to next again. This is really weird. Why is this not? Must be something to do. What if this is some weird G put a lab thing? Yeah, okay, I think what happened was that because I had used the graphical debugger, it broke the normal debugger. Okay, so let's start again. So, so I hit n for next, and that's still not really working. Okay, no worries. Let's switch to a regular Jupyter because I know it'll work there. Okay, and here we are. Okay, descent, descent debug for I n range 10 and i. Now, curious. What if I put this in a function with a function? Oh, okay. I don't know. I pretty much always debug things that are in functions. So that's what's going on. Okay, so I create a little function. I put subcent debug, I called the function. And then the first thing I did is I take s steps into the current function. So this is pointing out the thing it's about to run. It's about to run the thing called define f. So we're now inside the definition of f. And now it's going to run something for i in range 10. So n is next. So n just advances one instruction. So now that I've done that, I should exist. So you can print the contents of something by pressing p, and then the thing you want to print. So i is now zero. And so then I can go next. And in fact, you don't even have to type n. If you just hit enter, it redoes the last thing you did. So that just jumps to the next line. And so I can p I. Okay, now it's one. And so you get the idea. So basically, and then I can type l to list the file that I'm currently at. I can also see w to see like what called this, which it was actually called in this case by i Python or by deep notebook. So this is how I always debug things. And I'm sure at some point, well, actually need to debug something. I thought I'll just quickly show you that. Fergs here who have used both the graphical and the regular Python debugger, do you have any preferences or anybody here that has just used one or the other and likes it doesn't like it. I have only used the text debugger. Yeah, I love it. Yeah, wonderful, especially learning about, you know, doing the first day, of course, you can just put set stress wherever you'd like. And you are immediately transported to there. So for instance, when working on a new architecture where implementing some architecture of, I don't know, my own idea or trying to re implement something, I create my own class, and then I can step through the shapes of the tensor. It's just super useful. Yeah, so you mentioned set trace. So, pdb stands for the Python debugger. So set trace is very useful. It's how you set, oopsie does it, it's how you set a breakpoint. It may seem like a weird way to set a breakpoint, but basically, if we run this now, we don't even have to say percent percent debug, it jumps into the debugger immediately after that set trace call. So you can put that not only in your own Python files, but in Python files that you've installed from pep or condor or whatever, and then step through it in the way we just talked about hit n and start running through and check the values of variables, whatever. Oh, I didn't say how to exit. You press q for quick. If you're learning in your library, this is super useful because you just put the library from GitHub, you do pep at the temple install, and then you literally can step into the code that you're reading about. So, like, very synthesis. And also, basically, pretty much every major programming language debugger works the same way. So you can, yeah, if you're doing c code, there's a debugger called gdb that works the same way. If you're doing pep or code, the pep or debugger works the same way, they'll have the same keyboard shortcuts, the same way of working. So, it's skills you can reuse. And that's another thing, like, in general, I really try to avoid, you know, unless they're really, really good, but in general, proprietary tools, I generally avoid instead, try to use tools that I can use everywhere, because then I don't have to learn as many things. I can learn a small number of things and reuse them all the time. And particularly these, like, really old tools, like the way the Python debugger works goes back a long time, even before Python existed, these tools have been developed over many years to get, make them really perfect, you know, really to make them work really well by many people. And so they're very nicely optimized once you learn them. And they do take some time to learn. But if you're doing these work throughs, then you're the kind of person who's prepared to put in that time. So there's another thing related to what Jeremy just talked about. And those are key bindings in things like TMAX or even in Jupyter Notebook that we're looking at right now. So my normal intuition and what I would do a couple of years ago, when I jumped into something new, oh, I would just come up with my own unique key bindings that, hey, they will make life comfortable for Radit. They make it, you know, they're ergonomic and they're easy to remember. But then as we switch to a new environment, you sort of have to bring the key bindings with you, which is a horrible pain. So just like Jeremy mentioned that he tries to use software that is readily available. A way to shoot yourself in the foot would be to come up with your intricate key bindings. It's just sometimes very useful to go with the key bindings that are already there. And I mean, and even more importantly, learning to use the keyboard for everything is a good idea. I tend to use the mouth a little bit for teaching because I want people to see what I'm doing. But in normal life, I hardly ever touch my mouth because I'm just zipping around. So yeah, there's a few tips. Okay. Just a question, slightly on a different topic, but on the same thing, if the library behind this notebook has changed or get upgraded, how do we get the latest? That's what we're going to do right now. So, exactly. Okay. So let's say I want to upgrade something or install something in this environment, in this on this paper space server. No, as we discussed, a paper say service, not really a server at all. And so if I people ponder install something, it's actually not going to be here next time I come here. So that's a bit of a bummer. So how do we fix that? It's we're actually going to learn a lot in order to fix this. The first thing to know is that paper space has this idea of persistent storage. And specifically, there's a directory called slash storage, which contains your persistent storage. And so as you can see, even though I only just created this server, you know, just now there's already things in here. And that's because that's my persistent storage. So this is basically a mounted network drive. You can see all of the drives and how much room you've got on each one by using diff df, which is disk free. And then if you remember minus h is the human eyes, it tells you sizes in like gigabytes and megabytes and stuff. And so here's a list of all the disks that paper spaces provided for me. And so there's one called slash, which has got 168 gigabytes available. And here's my storage, which has got 496 gigabytes available. So that like that by default, the free for free, you get five gig. I just feel pretty good, right? But for eight bucks, you get 15 gig, which is a hell of a lot better. Not all of these are rideable. So for example, they have actually a slash data sets thing mounted there for you, which is kind of cool, because you can actually start using data sets that's used by fast AI straight away, which is pretty nice. Yeah, they're the main ones, basically. So what are we going to do about this, you know, slash storage? This is really where we want to install pip libraries or Conda libraries too. So let's just try to think of anybody think of a pip library they want to install. Any favorite ones? You use something like auto pip eight or Jedi or something like that. Yeah, I'm sorry. Maybe we'll just be able to let a version of a fast core. So normally to install the latest version of something, so you can use people kind of for this actually, for installing stuff kind of like locally, the way we're describing it, it's actually going to be easier to use pip than Conda. So we're going to use pip in the in a past lesson, I said like avoid pip. You know, I think we're down actually at a point where we can talk about where it's okay to use pip. So pip is a perfectly good way to install things which just contain Python code, or which you kind of pretty self contained. You wouldn't normally want to pip install PyTorch because it requires like CUDA and stuff. And yeah, pip doesn't really have a way of installing those kind of libraries. That's why if you use pip to install PyTorch, you have to like separately install the Nvidia software development kit with Conda, you don't have to. But for a library like fast core, and in fact, honestly, most libraries, you know, that like GPU kind of libraries, pips actually fine. And so normally to upgrade software with pip, you would type pip minus u, and then you type the thing that you want to upgrade. Or if you just want to install it, you do it without the minus u. There's an extra flag you can use, which is minus minus user. And that's going to install it into your home directory. And so there's lots of reasons you would want to do that. For example, if you don't have root access, or like in our case, we don't have the ability to like save the stuff in the root directory. So if I run that, oh, and of course, I have to say install. Okay, so it's upgraded it from 1.4 to 1.4.3. So let's see if that actually worked. Jeremy, why are you using like is Mamba not an option for this? Yeah, so this is this is it's not a great option for installing stuff into a user directory. At least I'm less familiar with with that. This is a way that I know is going to work fine for this special situation where we want to put stuff into our, into our home directory. So yeah, Mamba and Condor kind of synonyms, Mamba's a faster way to do it. Whereas pip is a different thing altogether. And it has it has this special thing I'm showing you right now, which is minus minus user. And if Condor or Mamba has such a thing, I don't know about it and haven't learned how to use it yet. I'm not saying it doesn't exist, but at least for pip, this works fine. So if we now look at fast cause version, there we go. So it has in fact installed 1.4.3. Now where did it put that? So oops, here in our home directory, you can see it's actually created something called dot local and dot local is where pip puts stuff that you install with dash, dash user. And as you can see, it's got various sub directories. And here is fast core. So if we want to be able to continue to use the latest version of fast core next time, we start this notebook server. We want this dot local directory to still be there. Right. So how do we do that? Well, what we can do is we can actually put that into our storage. So we could move that into our storage. Now, we've, okay, that's all very well, but we've that it's, it will now be in storage next time we come back. But Python needs it to be here in our, in our home directory. So what do we do? Well, what we have to do is we have to make it so that dot local in our home directory and dot local in our persistent storage are the same thing. And the way we do that is something with something Radik was mentioning before, which is using a sim link or a symbolic link. If I say ln for link and minus s for symbolic, and I say what's the thing that you want to symbolically link? And I say it's slash George slash dot local. That's the thing I just moved. Then you'll find that in this directory, oops, if hidden, there is now a dot local, but it looks special. Looks different. And it's like saying, oh, it's not a folder at all. It's actually just pointing at this other place. But it's like it really exists. I can, I'll ask it, for example, I can cd into it. And remember to say the last token from the previous line, I said this before is exclamation mark dollar. So that'll be dot local. You can see it does cd dot local. So yeah, it's basically like a, it's not a copy of it. It's like a shortcut into it. In fact, I think on Mac, they're called aliases and on windows, they're called shortcuts. It's the same thing. And on eudix type things, it's called a similar, a symbolic link. So now if I run i Python again and check the version, yep, it's still 1.4.3. So it's still finding it. So this way, we can actually make sure we've got, you know, that we can install and upgrade packages and still see them every time we launch, even if it's a new notebook server or relaunch an existing one or whatever. We just have to make sure that every time we start a new paper space instance, that it creates these any sim links we want. And so paper space has this really nifty thing, which is you can create a file called dot bash dot local in storage. And it will run that file every time you start a notebook. And so you'll see I've got a file there that goes through and creates a sim link to dot SSH and to dot local and to dot git credentials and a bunch of stuff that we haven't talked about all of them yet and dot caggle and sim links them all to slash storage. And so this way, every time I start a new computer, I'm going to have all that stuff set up automatically, which is, yeah, I think it's pretty, which is pretty great. So that's how you can customize your paper space instance. So Jeremy, just to recap there, to make sure I've got that clear in my head and for everyone else, too. So essentially what you've done is that you've got this bash script that you keep inside your persistent storage, which contains all your config and bits and pieces that you want. And then every time you fire up a new instance, you're just sim linking all that stuff you've got in storage to the machine you've just created. Yeah. Yeah. And in particular, you know, after I type, you know, pip install minus minus user something, it's created this dot local directory. So, and that's something that I want to be persistent. So I move that into storage and then sim link it back to where it's meant to be understood. Thanks. And the reason that you're doing this is because you can't get access to the the root directory on their server. Like, would you need to do this on your own computer? No, this is just for paper spaces. Not that I can't access it, Mark, I can, I can install it. But the problem is, these are not real servers. That's not that that's not persisted. So if I took when in five hours time, when this shuts itself down, and then I start up the server again, it's not there. It's it's a it's a mock server. It looks like it's your own server, but it doesn't actually keep your changes. So unless they're necessary only on virtual machines, but like on a on your own computer, you wouldn't need this is not only just this is like just this one. This is just paper space. Yeah, this is just for paper space. And we're spending time talking about paper space because it's so much better than any other option out there for for GPU servers. Like they're the only ones that have these nifty tricks. Yeah, on your own computer, you don't have to worry about any of this stuff. And if you've got your own GPU, you certainly don't have to worry about it. But you know, there are other notebook servers like Google CoLab, or whatever, but they don't have anything like this. So on Google CoLab, you're going to have to like reinstall everything you need every time you start up a new notebook. And you know, you won't have any of this proper environment. So yeah, as I as you might have seen, even my SSH keys are sim linked here. So I'm always going to have my SSH keys anytime I create a new paper space instance. So yeah, this is like a super convenient way to have a free GPU server whenever you want it, which I think is pretty amazing. Jeremy, a question I followed what you did in terms of installing people installing the fast core. But then when I use Python and try to import fast core, it throws an error. But when I do iPitan and import fast core, it can find it, does it? That's interesting. Do you want to share your screen and we could try to I'll see back that. I might have to stop sharing first. Let's see. Okay, I stopped sharing. Okay. Should share now. Let me know. We're not saying here comes. I forgot to press. Okay, so let's have a look. So this is on paper space and you went pip install good and you went Python. Interesting. Okay, so great. So press control D to exit from iPython. And you can press it again or hit enter. You didn't actually have to press Y, see how it's in square brackets. That means it's a default. So you can just do it. Okay, so let's find out what's going on. So type which Python. Okay, so Okay, and then type which iPython. I've got a strong suspicion. Try typing Python 3 instead of Python. So type Python 3 or one word. Not which Python. Okay, now try importing first core. Interesting. Let's see if I have the same problem online. So Python. Import first core. Oh, I'm getting the same error in mine. Very interesting. Okay, I'm going to share my screen again. Very well spotted. So this is exactly the kind of bug that I want us to have so we can learn how to hopefully fix it. I wonder if because how do you ever just run Python and I've only recently started using pip install user because it's because of this paper space thing. So I wonder if it's something specific to pip store user. So let's see if we can debug this. Actually, what's interesting is that module name first core is actually very interesting because that means it also doesn't have fast AI. Which. Yeah, okay, so the way Python finds modules is a very similar idea of how bash finds executables as there's a path basically. And so in Python, there's a module called sys which is where all kinds of things are stored. And so if we go sys. There's a sys.path. Now this is not the. This is not the bash path environment variable. This is a totally separate thing with a similar name, which is an all lower case path, sys.path in Python. This is a list of places that Python will search for Python libraries. Now, if I. Import first core. And you can see it's getting it from opt conda lib python 3.7 site packages. And you can see that is in my sys.path. So that's how it's finding first core. So why isn't Python finding it? Well, we could do the same thing. Um, sys.path. So that's interesting. So Python here is not including site packages. Whereas, where as I Python is. So there's something I guess about how um, package space of installed things because I'm pretty sure that's not what happens here. Let's try it. Python import sys, sys.path. Yeah, so here's site packages. Um, so. Let's see what happens if we. Site packages. So this is a, this is like the normal place that pep and kind of install things is into the site packages directory. Um, and yeah, I've never really looked into it because I've never had problems accessing it before. Oh, it's something to do with Debian puts things in in just packages. That's interesting. Site packages not in path. Um, Jeremy, why is this talking to me? Hang on a sec. Sorry. Oh, go on. Yes. Sorry. No, just when you were looking at those two paths, one was 3.7 and one was 3.9. I guess there were two different. Oh, I didn't even notice that. Is that sure? Um, You mean here? 3.9? Yeah. And 3.7. There you go. You're quite right. Thank you. Okay. So that'll be the reason. Um, which Python, which I Python. Yes. Okay. Yeah. All right. So it wasn't just a case for typing Python three. It was a case of typing Python 3.9. There we go. Oh, still not there. Oh, it's 3.7 that I Python is using Python 3.7. Uh, huh. Okay. Thanks. That's exactly what it was. I don't know why they've got so many Python installed. It seems a bit like overkill. So the Python 3.9 here was the system by temporary and that I didn't read and was I mean, because we're on paper space, um, I think they were all, um, which Python, which Python 3, they're actually all the ones in Conda. So it's, so paper space is installed. Conda is the root. And so none of these are the system Python, actually. Um, yeah, paper space is a bit unusual in that they have us run as root. Um, so things are a little bit confusing, actually. Um, yeah. Now as to why I Python is running 3.7. Um, I'm actually not sure. Um, so something else that I do is, um, is I create a get directory and obviously I create a get directory. Um, and then I get clone things into it using my SSH keys. Um, and then what I do, then what I do is I move the get directory into slash storage and then sim link it back. Um, and actually where I sim link it to, I don't actually sim link it to my, um, home folder actually sim link it inside slash notebooks. And the reason for that is that, um, that's where, um, uh, that's where paper space uses as the root of its Jupiter lab. So actually you can see here I've done it before, um, because it's in slash storage, right? So you can see here's my, my get stuff. And so I actually think, you know, it's, I don't really want any of this stuff that they've put put in here for me. Um, so actually maybe I should try deleting. In fact, let's try that. What happens if we, um, um, create a server and we make that get repo thing empty. Because that's really what I want. So we've uploaded your SSH keys into paper space. Yeah, I've uploaded them and I've put them in slash storage and in my dot, but slash storage slash dot bash RC dot local, I sim link them into my home directory. Correct. I'm not entirely paranoid about such things. Yeah. I mean, if you were, if you were paranoid about things, then create a separate SSH key pair just for this and put that in your GitHub. So then people, if somebody steals your SSH private key, the worst thing they could do is to get into your GitHub. That's so cool. I didn't think about that. Wonderful. We'll do that. Um, all right. So what would happen? Let's get overkill for notebooks at the moment. Let's delete some of these. Um, so yeah, but for me on paper space, um, you know, everything's kind of going into that slash storage. So I don't really care about deleting things. All right. So if I, will it let me delete this? Because that's really what I want to do. So I pressed delete. It's still showing me this. I don't know if that's a default or if it's just an example. Well, I'm here. So I just want to mention maybe, sorry, maybe I'm the only one. Um, I understand it in principle, but you're talking about with the SSH keys and importing them and everything, but the details of the execution. If I'm the only one that's fine, I'll struggle with it. Oh, yeah. Let's let's do that. I don't know that I can actually do it. Yeah, let's do it. I, that's, that's excellent. Thank you. Um, one thing I just want to do for my own interest is I'm just going to jump onto YouTube and see if anybody actually watches these live streams. Because if they don't, I won't waste my time running them. Yeah. I'm not sure it's worth it. I might just assume in the future. Did you know your hands are credit, by the way? Yeah. So. You don't have to put your hand up. You can just talk. Okay. Okay. Um, you know, some libraries, the more exotic ones, like I'm not sure maybe grabs this or that they require to use something, yeah, I'll just install some library. Oh, yeah. Let's talk about that as well. Great. Um, okay. So this thing has successfully started in the machine. Let's see if there's anything in it. So I was just starting the machine wouldn't delete it. The git repo thing. Yeah. Okay. Great. So this is actually just empty. This is actually probably what I would be more inclined to do. Although I expected to see my slash get there. Oh, wait. Okay. All right. Here's an interesting problem. That dot bash RC. Local file. It runs when you run a terminal. So my git folder, SimLink, didn't appear until I actually opened a terminal. As soon as I did that. It appears. Um, and I probably hadn't noticed that before, because I always run a terminal as soon as I start. Pretty much. Um, there is a way actually. That what they actually run when you start a notebook, when you start a server is it actually runs this file run.sh, which we can't change. But, um, it does actually have a pre run.sh file, which is, if you put stuff in slash storage slash pre run.sh. It will run before Jupiter starts, which maybe is actually a better place for all the stuff I'm doing. Maybe that's what we should use instead of dot bash RC dot local. Because this only runs when you run a terminal. Yes, interesting. Let's try that. Actually, I'd forgotten. It looks like I have got local member stuff working as well. Maybe we can try that next time. So, um, by the way, to look at the, the end of a file, you can just type tail. So if I go tail slash run dot sh. Um, there it is. So if I move dot bash RC dot, sorry, dot bash local to pre dash run.sh. All right, let's try that. So, if we now create a new notebook. If you're wondering why it is, by the way, that paper space is so perfectly set up for everything to work really well. It's because I've basically been nagging the perks of paper space for the last. Four years about all these things and actually it's just really in the last three months that they actually really started listening and they've. I told them put this here, put this here, then it's going to be great. So they actually, yeah, they've been really great, particularly recently. That's setting everything up exactly the way we need it. Okay. So delete that. And so I think, yeah, see here's that command slash run dot sh. So I guess what you could do, by the way, is you could like put some different, like your own URL here, and it's going to like automatically put that in slash notebooks. And maybe you could even put a shell script then that comes from github. I haven't really thought about that. Anyway. Okay. So I think it was Mark that was asking, how would I actually get my dot SSH keys onto this machine. The short that I think the easy way to do it would be to use the upload file feature in JupyterLab. This is a really handy feature to know about. So you see this little button here upload files. So you could click that, and then you could go into your. Ssh folder. And find the files you want to upload and upload them. So for example, I do config, and you can see here it appears. And so then if I open my terminal. There it is there. Right. And then you could just move that to where you need it. One tip with SH keys actually. In fact, let's do it from scratch. That's what I meant to be doing. Let's do it from scratch to make sure everything works. So I'm going to arm.sh. Okay. So let's do it from scratch. Ssh keys actually have to have very exact permissions on them. If they're if it's possible for anybody else to read or write your SSH keys SSH will refuse to use them. And so one way to actually see the correct permissions is to create some SSH keys. So I could go SSH dash key gen. Enter, enter, enter, and then I can go LS minus LA dot SSH. And so to remind you we just briefly see this the other day, the permissions. These three here tell you this user, which is root, can they read, write, and execute the file. So this user. So the root can read, write, and execute the practices of private key file. And it can also read, write, and execute the public, sorry, read and write the public key file. These three here is what about everybody else. And this says everybody can read the public key file. But they can't do anything to the private key file. And then dot refers to the current directory. So the directory itself. Only the root user can read, write, and execute the directory. The idea of executing a directory might sound weird. It actually refers to seeing what is in a directory. They call executing a directory. So let's upload. So I'm going to put the key. Okay, so there they are. Now they're going to be put into slash notebook slash git. So if I go cd dot SSH, and then I'll move slash notebook slash git slash IDRSA. Now if I hit tab again, it'll show me that there's multiple things starting with those letters. So I'm going to move all of those things into the current directory. So the current directory, remember, is dot. So dot slash. And so there they now are. And now they don't have the right permissions anymore. My private key is readable by everybody, which is no good. So to change permissions, we say CH mod change. I don't know what's called mod rather than CH per modeling. And we can say that the group and the user should not have read permission. So the user and the group subtract read permissions on the private key. And then check again. Oh, I shouldn't have said user and group. What I meant to say, it just gave remove permissions for myself to read it. I meant should have said group and everybody, which I think is all. So, the first three dashes are for user. The next three dashes are for the first is for directory or not directory, but the next three dashes. Yeah, go on. The next three dashes are for user. The next three dashes are for group. And the last three dashes are for everyone. That's correct. Okay, that's what we want. So now the user can read and write the private key. So, we can test this by SSHing to github.com and github.com expects you to log in with the user name get. So when you SSH before the app sign, you say the user name to login as. And by default, it uses your current username, which is root. I definitely can't log in to github.com is root. GitHub.com. Yes. Great. Hello, JPH. So it knows who I am, right, because it knows who has my public key in that account. You've successfully authenticated. And then it closes it because you can't actually use a terminal on github.com. It's only used for forget, but you can see my key is working. So, I'm just going to ask, wouldn't it be simpler or am I missing something to generate a new key in paper space rather than imported and then just give github that new key. Maybe. I don't know. I'm just thinking with all these, with all these like changing, with all these changing of permissions and stuff. I'm going to say like, okay, so I, obviously I don't think so because I don't do it that way. But if I think about why I don't do it that way, like some people do it your way. Your way is in many ways, more correct in that you would have different public keys on github.com for every machine you're using. And if somebody like stole a machine, you could delete just that public key and that person now couldn't log in, but you could still log in and maybe that's more convenient or something. It's a perfectly fine way to do it, Mark, honestly. I don't like the mental overhead of having to think about having multiple keys and which is which and because like I've had a good up account for quite a long time and probably used. I don't know, maybe a hundred different machines to access it and I don't like the idea of having a hundred public keys and thinking where, where are they and should they still be there. Yeah, I think it's fine. So that was actually pretty intense today. So for folks who, you know, just getting started. There was nothing we'd use today I don't think that we haven't learned how to use before. But it's tough using things that you've only just learned about and so therefore you know, it does need a lot of practice. So, if you're kind of new to this, then yeah, then like, you probably want to rewatch the video and like, also pepper me with questions next time. If you try things and, and it doesn't work. Or you're not sure why we do it or whatever. All right, anything else before we yeah. Yeah, what about these things you have to have to install. Okay, let's do that next time. Yeah, next time. I will put it on the forum. Thanks so nice to see you all. So much. Bye. Thank you. Bye. Bye. Thank you.
