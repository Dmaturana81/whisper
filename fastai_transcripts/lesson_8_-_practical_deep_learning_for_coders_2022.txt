 So welcome to the last lesson of part one of practical deep learning for coders. It's been a really fun time doing this course. And depending on when you're watching and listening to this, you may want to check the forums or the fast.ai website to see whether we have a part two planned, which is going to be sometime towards the end of 2022. Or if it's already passed that, then maybe there's even a part two already on the website. So part two goes a lot deeper than part one, technically, in terms of getting to the point that you should be able to read and implement research papers and deploy models in a very kind of real life situation. Yeah. Last lesson we started on the collaborative filtering notebook. And we were looking at collaborative filtering and this is where we got to, which is creating your own embedding module. And this is a very cool, this is a very cool place to start the lesson, because you're going to learn a lot about what's really going on. And it's really important, before you dig into this, to make sure that you're really comfortable with the zero five, the model and neural net from scratch notebook. So if parts of this are not totally clear, put it aside and redo this notebook. Because what we're looking at from here are kind of the abstractions that pie torch and fast AI add on top of functionality that we've built ourselves from scratch. So if you remember in the neural network from scratch we built, we initialized a number of coefficients, a couple of different layers, you know, and a bias term, and then during as the model trained we updated those coefficients by going through each layer of them and subtracting out the gradients by the learning rate. In you probably noticed that in pie torch we don't have to go to all that trouble. And I wanted to show you how pie torch does this pie torch. We don't have to keep track of what our coefficients or parameters or weights are pie torch does that for us. And what it does that is it looks inside our, our module, and it tries to find anything that looks like a neural network parameter, a tensor of neural network parameters. And it keeps track of them. And so here is a class we've created called T, which is a sub class of module. And we've created one thing inside it which is something with the attribute A. So this is a in the T module. And it just contains three ones. And so the idea is, you know, maybe we're creating the module and this is we're initializing some parameter that we want to train. And we can find out what trainable parameters or just what parameters in general pie torch knows about in our model by instantiating our model and then asking for the parameters, which you then have to turn that into a list or in first call we have a thing called capital L, which is like a fancy list, which prints out the number of items in the list and shows you those items. Now in this case, when we create our object of type T and ask for its parameters, we get told there are zero tensors of parameters and a list with nothing in it. And why is that we actually said we wanted to create three, a tensor with three ones in it. How would we make those parameters. Well, the answer is that the way you create your way you tell pie torch what your parameters are is you actually just have to put them inside a special object called an nn dot parameter. This thing almost doesn't really do anything. In fact, last time I checked it really quite literally had almost no code and sometimes these things change but let's take a look. Yeah, okay so it's about a dozen lines of code or 20 lines of code, which does almost nothing it's got a way of being copied. It's got a way of printing itself, it's got a way of saving itself, and it's got a way of being initialized. So the parameter hardly does anything the key thing is though that when pie torch checks to see which parameters to the update when it optimizes, it just looks for anything that's been wrapped in this parameter class. So if we do exactly the same thing as before which is to set an attribute containing a tensor with three ones and not. But this case we wrap it in a parameter. We now get told okay there's one parameter tensor in this model, and it contains a tensor with three ones. And you can see it also actually by default assumes that we're going to want require gradient. It's assuming that anything that's a parameter is something that you want to calculate gradients for. Now most of the time we don't have to do this because pie torch provides lots of convenient things for us such as what you've seen before and end up linear, which is something that also contains creates a tensor. So this would contain a created tensor of one by three without a bias term in it. This has not been wrapped in an end parameter, but that's okay pie torch knows that anything which is basically a layer in a neural net. It's going to be a parameter. So it automatically considers this a parameter. So here's exactly the same thing again I construct my object of type T of check for its parameters. And I can see there's three of one tensor of parameters and there's our three things. And you'll notice that it's also automatically randomly initial initialize them, which again is generally what we want. So pie torch does go to some effort to try to make things easy for you. So the, this attribute a is a, is a linear layer and it's kind of a bunch of things in it. One of the things in it is the weights. And that's where you'll actually find the parameters that is of type parameter. So a linear layer is something that contains attributes of type parameter. Okay, so what we want to do is we want to create something that works just like this did, which is something that creates a matrix, which will be trained as we train the model. Okay, so an embedding is something which, yeah, it's going to create a matrix of this by this. And it will be a parameter and it's something that we need to be able to index into as we did here. And so how yeah what is what is happening behind the scenes, you know, we're in pie torch it's nice to create these things ourselves and scratch because it means we really understand it. And so that's create that exact same module that we did last time. But this time we're going to use a function of created called create params, you pass in a size. Such as in this case, and uses by N factors. And it's going to call torch.zeros to create a tensor of zeros of the size that you request. And then it's going to do a normal random distribution so a Gaussian distribution of mean zero standard deviation 0.01 to randomly initialize those. And it'll put the whole thing into an end up parameter. So that so this here is going to create an attribute called user factors, which will be a parameter containing some tensor of normally distributed random numbers of this size. Excuse me. And because it's a parameter that's going to be stored inside that's going to be available as in parameters in the module. I'm sneezing. So user bias will be a vector parameters user factors will be a matrix of parameters movie factors will be a matrix and movies by N factors movie bias will be a vector and movies. And this is the same as before. So now in the forward we can do exactly what we did before. The thing is when you put a tensor inside a parameter, it has all the exact same features that a tensor has. So, for example, we can index into it. So this whole thing is identical to what we had before. And so that's actually, believe it or not, all that's required to replicate pie torches embedding layer from scratch. So let's run those and see if it works. And there it is, it's training. So we'll be able to have a look when this is done at, for example. Model dot, let's have a look movie bias. And here it is, right? It's a parameter containing a bunch of numbers that have been trained. And as we had expect, it's got 1665 things in because that's how many movies we have. So our question from Jonah Raphael was, does torch dot zeros not produce all zeros? Yes, torch dot zeros does produce all zeros. But remember a method that ends in underscore changes in place, the tensor is being applied to. And so if you look up pytorch normal underscore, you'll see it fills itself with elements sampled from the normal distribution. So this is actually modifying this tensor in place. And so that's why we end up with something which isn't just zeros. Now this is the bit I find really fun is we train this model. But what did it do? How is it going about predicting who's going to like what movie? Well, one of the things that's happened is we've created this movie bias parameter, which has been optimized. And what we could do is we could find which movie IDs have the highest numbers here and the lowest numbers. So I think this is going to start lowest. And then we can print out we can look inside our data loaders and grab the names of those movies for each of those five lowest numbers. And what's happened here? Well, we can see broadly speaking that it has printed out some pretty crappy movies. And why is that? Well, that's because when it does that matrix product that we saw in the Excel spreadsheet last week, it's trying to figure out who's going to like what movie based on previous movies people have enjoyed or not. And then it adds movie bias, which can be positive or negative. That's a different number for each movie. So in order to do a good job of predicting whether you're going to like a movie or not, it has to know which movies are crap. And so the crap movies are going to end up with a very low movie bias parameter. And so we can actually find out which movies to people, not only which movies to people really not like, but which movies to people like like less than one would expect given the kind of movie that it is. So, lawnmower man to, for example, not only apparently is it a crappy movie, but based on the kind of movie it is, you know, it's kind of like a high tech pop kind of sci fi movie. So people who like those kinds of movies still don't like lawnmower man too. So that's what this is meaning. So it's kind of nice that we can like use a model not just to predict things, but to understand things about the data. So if we saw it by descending, it'll give us the exact opposite. So here are movies that people enjoy, even when they don't normally enjoy that kind of movie. So for example, LA confidential, classic kind of film, detective movie with the Aussie guy, Pierce, even if you don't really like film, while detective movies, you might like this one. You know, silence of the lambs, classic kind of, I guess you'd say like horror kind of, not horror is it, it's a suspense movie. Even people who don't normally like kind of serial killers as bands movies tend to like this, this one. Now, the other thing we can do is not just look at what's happening in the bias. By the way, we could do the same thing with users and find out like which user just loves movies, even the crappy ones, you know, just likes all movies and vice versa. But what about the other thing? We didn't just have bias. We also had movie factors, which has got the number of movies as one axis and the number of factors as the other and we passed in 50. What's in that huge matrix? Well, pretty hard to visualize such a huge matrix. And we're not going to talk about the details, but you can do something called PCA, which stands for principal component analysis. And that basically tries to compress those 50 columns down into three columns. And then we can draw a chart of the top two. And so this is PCA component number one, and this is PCA component number two. And this is a compressed view of these latent factors that it created. And you can see that they obviously have some kind of meaning. So over here towards the right, we've got kind of, you know, very pop mainstream kind of movies. And over here on the left, we've got more of the kind of critically acclaimed gritty kind of movies. And then towards the top, we've got very kind of action oriented and sci fi movies. And then down towards the bottom, we've got very dialogue driven movies. So remember, we didn't program in any of these things and we don't have any data at all about what movie is what kind of movie. But thanks to the magic of SGD, we just told it to please try and optimize. These parameters. And the way it was able to predict who would like what movie was it had to figure out. What kinds of movies are there or what kind of taste is there for each movie. So I think that's pretty interesting. So this is called visualizing embeddings. And then this is visualizing the bias. We, we obviously would rather not do everything by hand like this, or even like this. And fast AI provides an application for collaborative learner. And so we can create one and this is going to look much the same as what we just had. We're going to say how many latent factors we want. And what the Y range is to do the sigmoid in the model play. And then we can do fit. And away it goes. So let's see how it does. All right, so it's done a bit better than our manual one. Let's take a look at the model it created. The model looks very similar to what we created in terms of the parameters. You can see these are the two embeddings and these are the two biases. And we can do exactly the same thing. We can look in that model and we can find the, you'll see it's not called movies. It's I for items. It's users and items. This is the item bias. So we can look at the item bias grab the weights. Sort. And we get a very similar result. And this case, it's very even more confident that LA Confidential is a movie that you should probably try watching, even if you don't like those kind of movies. And Titanic's right up there as well, even if you don't really like romance, he kind of movies, you might like this one. Even if you don't like classic detective, you might like this one. You know, we can have a look at the source code for collab learner. And we can see that. Let's see, use and it is false by default. So our model is going to be of this type embedding.bias. So we can take a look at that. Here it is. And look, this does look very similar. Okay, it's creating an embedding using the size we requested for each of users by factors and items by factors and users and items. And then it's grabbing each thing from the embedding in the forward. And it's doing the model play. And it's adding it up and it's doing the sigmoid. So yeah, it looks. It looks exactly the same. Isn't that neat. So you can see that what's actually happening in real models is not. Yeah, it's not. It's not that weird or magic. So, Korean is asking is PCA useful in any other areas. And the answer is absolutely. And what I suggest you do. If you're interested is check out our content computational linear algebra course. It's five years old now, but it's, I mean, this is stuff which hasn't changed for decades really. And this will teach you all about things like PCA and stuff like that. It's not nearly as directly practical as practical deep learning for coders, but it's definitely like very interesting. And it's the kind of thing which if you want to go deeper, you know, it's, it can become pretty useful later along your path. Okay. So here's something else interesting we can do. Let's grab the movie factors. So that's in our model. It's the item weights and it's the weight attribute that PyTorch creates. Okay. And now we can convert. The movie silence of the lambs into its class ID and we can do that with object to ID for the titles. And so that's the movie index of silence of the lambs. And what we can do now is we can look through all of the movies in our latent factors and calculate how far apart the each vector is each each embedding vector is from this one. And this cosine similarity is very similar to basically the Euclidean distance, you know, the kind of the root sum squared of the differences, but it normalizes it. So it's basically the angle between the vectors. So this is going to calculate how similar each movie is to the silence of the lambs on based on these latent factors. And so then we can find which ID is the closest. Yeah, so based on this embedding distance, the closest is dial M for murder. It makes a lot of sense. I'm not going to discuss it today, but in the book, there's also some discussion about what's called the boots japping problem, which is the question of like, if you've got a new company or a new product. How would you get started with making recommendations given that you don't have any previous history with which to make recommendations. And that's a very interesting problem that you can read about in the book. Now, that's one way to, to do collaborative filtering, which is where we create that. Do that matrix completion exercise using all those dot products. There's a different way, however, which is we can use deep learning. And to do it with deep learning, what we could do is we can, we could basically create our user and item embeddings as per usual. And then we could create a sequential model. So sequential model is just layers of a deep learning neural network in order. And what we could do is we could just concatenate. So in forward, we could just concatenate the user and item embeddings together. And then do a value. So this is this is basically a single hidden layer neural network. And then a linear layer at the end to create a single output. So this is a very, you know, world's most simple neural net exactly the same as the style that we created. Back here in our neural net from scratch. This is exactly the same. But we're using pytorches functionality to do it more easily. So in the forward here, we're going to in the same exactly the same ways we have before, we'll look up the user embeddings and we'll look up the item embeddings. And then this is new. This is where we can concatenate those two things together and put it through our neural network and then finally do our sigmoid. Now, one thing different this time is that we're going to ask fast AI to figure out how big are embeddings should be. And so fast AI has something called get embedding sizes. And it just uses a rule of thumb that says that for 944 users, we recommend 74 factor embeddings and for 1665 movies. Or is it the other way around? I can't remember. We recommend 102 factors here embeddings. So that's what those sizes are. So now we can create that model and we can pop it into a learner and fit in the usual way. And so rather than doing all that from scratch, what you can do is you can do exactly the same thing that we've done before, which is to call collaborative learner. But you can pass in the parameter used neural network equals true. And you can then say how big do you want each layer. So this is going to create a two hidden layer deep learning neural net. The first will have 1500 and the second will have 50. And then you can say fit. And away it goes. Okay, so here is our, we've got 0.87. So these are doing less well than our product version, which is not too surprising because kind of the product version is really trying to take advantage of our understanding of the problem domain. In practice, nowadays, a lot of companies kind of combine, they kind of create a combined model that have a has a product component and also has a neural net component. The, the, the neural net components particularly helpful if you've got metadata, for example, information about your users, like when did they sign up, how old are they, what sex, are they, you know, where are they from. And then those are all things that you could can catenate in with your embeddings and did I with metadata about the movie, how old is it what genre is it and so forth. All right, so we've got a question from Jonah, which I think it's interesting and the question is, is there an issue where the bias components are overwhelmingly determined by the non experts in a genre. In general, actually there's a there's a more general issue which is in collaborative filtering. And so, we have a lot of recommendations systems. Very often. A small number of users are a small number of movies. Overwhelm everybody else. And the classic one is anime. A relatively small number of people watch anime and those group of people watch a lot of anime. And so, you can imagine what's happening in the matrix completion exercise. Is that there are. Yeah, some some users that just. You know, really watch this one genre of movie and they watch an awful lot of them. So in general, you've actually do have to be pretty careful about the. You know, these subtlety kind of issues. And yeah, we're going to details about how to deal with them, but they're generally involved kind of taking various kinds of ratios or normalizing things or so forth. All right. So that's collaborative filtering. And I wanted to show you something interesting. And I wanted to show you something interesting then about embeddings, which is that embeddings are not just for collaborative filtering. And in fact, if you've heard about embeddings before, you've probably heard about them in the context of natural language processing. So you might have been wondering back when we did the hugging face transformers stuff. How did we go about. You know, using text as inputs to models. And we talked about how you can turn words into integers. We make a list. So here's, here's the movie. Sorry, movie. Here's the poem. I am Sam. I am Daniel. I am Sam. Sam. I am. I am, et cetera, et cetera. We can find a list of all the unique words in that poem and make this list here. And then we can give each of those words. A unique ID, just arbitrarily. Well, actually in this case it's alphabetical order, but it doesn't have to be. And so we kind of talked about that. And that's what we do with categories in general. But how do we turn those into like, you know, lists of random numbers. And you might not be surprised to hear what we do is we create an embedding matrix. So here's an embedding matrix containing four latent factors for each word in the vocab. So here's each word in the vocab and here's the embedding matrix. So if we then want to present this poem to a neural net, then what we do is we list out our poem. I do not like that Sam. I am. Do you like green eggs and ham, et cetera? Then for each word, we look it up. So in Excel, for example, we use match. So that will find this word over here and find it is word ID eight. And then we will find the eighth word and the first embedding. And so that's gives us. That's not right. So it's just weird column. So it's going to be point two, two, then point one, point one. And here it is. Point one, point one, et cetera. So this is the embedding matrix we end up with for this poem. And so if you wanted to train or use a train neural network on this poem, you basically turn it into this matrix of numbers. And so this is what an embedding matrix looks like in an NLP model. And it works exactly the same way as you can see. And then you can do exactly the same things in terms of interpretation of an NLP model by looking at both the bias factors and the latent factors in a word embedding matrix. So hopefully you're getting the idea here that our, you know, our different models, you know, the inputs to them, they're based on a relatively small number of kind of basic principles. And these principles are generally things like lock up something in a ray. And then we know inside the model, we're basically multiplying things together, adding them up and replacing the negatives of zeros. So hopefully you're getting the idea that what's going on inside a neural network is generally not that complicated. But it happens very quickly and it's going. Now, it's not just collaborative filtering and NLP, but also tabular analysis. So in chapter nine of the book, we've talked about how random forests can be used for this, which was for this is for the thing where we're predicting the auction sale price of industrial heavy equipment like bulldozers. Instead of using a random forest, we can use a neural net. Now, in this data set, there are some continuous columns. And there are some categorical columns. Now, I'm not going to go into the details too much, but in short, the, we can separate out the continuous columns and categorical problem columns using content, and that will automatically find which is rich based on their data types. And so in this case, it looks like. Okay, yes, so continuous columns, the elapsed sale date. So I think it's the number of seconds or years or something since the start of the data set is a continuous variable. And then here are the cut the categorical variables. So, for example, there are six different product sizes and two couple of systems. 5,059 model descriptions, six enclosures, 17 tire sizes and so forth. And so, we can use fast AI basically to say, okay, we'll take that data frame and pass in the categorical and continuous variables and create some random splits. And what's the dependent variable? And we can create data loaders from that. And from that, we can create a tabular learner. And basically, what that's going to do is it's going to create a pretty regular multi layer neural network, not that different to this one that we created by hand. And each of the categorical variables, it's going to create an embedding for it. And so I can actually show you this, right? So we're going to use tabular learner to create the learner. And so tabular learner is 123456789 lines of code. And basically, the main thing it does is create a tabular model. And so then tabular model. You're not going to understand all of it, but you might be surprised at how much. So a tabular model is a module. We're going to be passing in how big is each embedding going to be. And tabular learner. What's that passing in? It's going to call get embedding sizes, just like we did manually before, automatically. So that's how it gets us embedding sizes. And then it's going to create an embedding for each of those embedding sizes from number of inputs to number of factors. Dropout, we're going to come back to later. Batch norm, we won't do to your part two. So then it's going to create a layer for each of the layers we want, which is going to contain a linear layer followed by batch norm followed by dropout. It's going to add the sigmoid range we've talked about at the very end. And so the forward, this is the entire thing. If there's some embeddings, it'll go through and get each of the embeddings using the same indexing approach we've used before. It'll concatenate them all together. And then it'll run it through the layers of the neural net, which of these. So yeah, we don't know all of those details yet, but we know quite a few of them. So that's encouraging, hopefully. And once we've got that, we can do the standard L R find and fit. Now, this exact data set was used in a, um, a Kaggle competition. This, this data set was in a Kaggle competition and the third place getter published a paper about their technique. And it's basically the exact, almost the exact one I'm showing you here. Um, so it wasn't this, sorry, it wasn't this data set. It was a data set. It was a different one. Um, it was about us predicting the amount of sales in different stores. But they, they use this basic kind of technique. And one of the interesting things is that they used a lot less. Manual feature engineering than the, the other high placed entries, like they had a much simpler approach. And one of the interesting things they published a paper. About their approach. So they published a paper about their approach. Um, so this is the team from this company. Um, and they basically describe here exactly what I just showed you, these, um, different embedding layers being concatenated together and then going through a couple of layers of a neural network. And it's showing here, it's, it points out in the paper exactly what we learned in the last lesson, which is embedding layers are exactly equivalent to linear layers on top of a one hot encoded import. Um, and, um, yeah, they found that, uh, their, their technique worked really well. One of the interesting things they also showed is that you can take, you can create your neural net, get your trained embeddings. And then you can put those embeddings into a random forest or gradient booster tree. And your main average percent error will dramatically improve. So you can actually combine, um, random forests and embeddings or gradient booster trees and embeddings, which is really interesting. Now what I really wanted to show you though, is what they then did. So as I said, this was a thing about, um, the predicted amount that different products would sell for different shops. Um, around Germany. And what they did was they, um, they had a, so one of their embedding matrices was embeddings by region. And then they did, I think this is a PCA principal component analysis of the embeddings. Um, for their German regions. And when they, um, could a chart of them, you can see that the locations that are close together in the embedding matrix are the same locations that are close together in Germany. So you can see here's the blue ones. And here's the blue ones. And again, it's important to recognize that the data that they used had no information about the location of these places. Um, the fact that they are close together geographically is something that was figured out as being something that actually helped it to predict sales. Um, and so in fact, they then did a plot showing each of these dots is a shop, a store, and it's showing for each pair of stores. How far away is it, um, in real life in metric space, and then how far away is it in embedding space. Um, and there's this very strong correlation. Right. So it's, you know, it's kind of reconstructed somehow. Um, this kind of the kind of the geography of Germany by figuring out how how people shop. And similar for days of the week. So there was no information really about days of the week, but when they put it on the embedding matrix, the days of the week. Monday, Tuesday, Wednesday, close to each other, Thursday, Friday, close to each other. As you can see, Saturday and Sunday, close to each other. And did over months of the year. January, February, March, April, May, June. So, yeah, really interesting cool stuff, I think. Um, what's actually going on and since inside a neural network. All right, let's take a 10 minute break, and I will see you back here at 7 10. All right, folks, this is something I think is really fun, which is we're going to we've looked at. What goes into the, the start of the model, the input. We've learned about how they can be categories or embeddings and embeddings are basically kind of one hot encoded categories, whether it'll compute trick, or they can just be continuous numbers. We've learned about what comes the other out the other side, which is a bunch of activation. So just a bunch of tensor of numbers, which we can use things like softmax to constrain them to add up to one and, and so forth. And we've looked at what can go in the middle, which is the matrix model place, sandwiched together with, you know, as rectified linear units. And I mentioned that there are other things that can go in the middle as well, but we haven't really talked about what those other things are. So I thought we might look at one of the most important and interesting version of things that can go in the middle. But what you'll see is it turns out it's actually just another kind of matrix modification, which might not be obvious at first, but I'll explain. We're going to look at something called a convolution, and convolutions are at the heart of a convolutional neural network. So the first thing to realize is a convolutional neural network is very, very, very similar to the neural networks we've seen so far. It's got imports. It's got things that are a lot like are actually are a form of matrix multiplication sandwich with activation functions, which can be rectified linear. But there's a particular thing, which makes them very useful for computer vision. And I'm going to show you using this Excel spreadsheet that's in our repo called conv example. And we're going to look at it using an image from MNIST. So MNIST is kind of the world's most famous computer vision data set, I think, because it was like the first one, really, which really showed image recognition being cracked. It's pretty small by today's standards. It's a data set of handwritten digits. Each one is 28 by 28 pixels. But yeah, back in the mid 90s, Jan LeCun showed really practically useful performance on this data set and as a result, ended up with conv nets being used in the American banking system for reading checks. So here's an example of one of those digits. This is a seven that somebody drew. It's one of those ones with a stroke through it. And this is what it looks like. This is this is the image. And so I got it from this is just one of the images from MNIST, which I put into Excel. And what you see in the in the next column is a version of the image where the horizontal lines being recognized. And another one where the vertical lines are being recognized. And if you think back to that Xyla and Fergus paper that talked about what the layers of a neural net does, this is an absolutely an example of something that we know that the first layer of a neural network tends to learn how to do. Now, how did I do this? I did this using something called a convolution. And so what we're going to do now is we're going to zoom in to this Excel notebook. And we're going to keep zooming in. We're going to keep zooming in. So take a look. Keep a layer on this on this image and you'll see that once we've seen enough. It's actually just made of numbers, which as we discussed in the very first. In the very first lesson, we saw how images are made of numbers. So here they are right here the numbers between zero and one. And what I just did is I just use little trick. I used Microsoft Excels condition or formatting to basically make things that higher numbers more red. So that's how I turn this Excel sheet and I've just rounded it off to the nearest decimal, but it's actually they're actually bigger than that. And so, yeah, so here is the images numbers. And so let me show you how we went about creating this top edge detector. What we did was we created this formula. Don't worry about the max. Let's focus on this. What it's doing is have a look at the colored in areas. It's taking each of these cells and multiplying them by each of these cells. And then adding them up. And then we do the rectified linear part, which is if that ends up less than zero, then make it zero. So this is a this is like a rectified linear unit, but it's not doing the normal matrix product. It's doing the equivalent of a dot product, but just on these nine cells and with just these nine weights. So you might not be surprised to hear that if I move now one to the right. Then now it's using the next nine cells. So if I move like to the right quite a bit and down quite a bit here. It's using these nine cells. So it's still doing a dot product, right, which as we know is a form of matrix multiplication. But it's doing it this way where it's kind of taking advantage of the geometry of the situation that the things that are close to each other. Being multiplied by this consistent group of the same nine weights each time. Because there's actually 28 by 28 numbers here, right, which I think is 768. That plus enough, 784. But we don't want we don't we don't have 784 parameters really have nine parameters. And so this is called a convolution. So a convolution is where you basically slide this kind of little three by three matrix across a bigger matrix. And at each location, you do a dot product of the corresponding elements of that three by three with the corresponding elements of this three by three matrix of coefficients. Now, why does that create something that finds as you see top edges? Well, it's because of the particular way I can start to this three by three matrix. What I said was that all of the rows just above. So these ones are going to get a one. And all of the ones just below are going to get a minus one. And all of the ones in the middle are going to get a zero. So let's think about what happens somewhere like here. Right. That is. Let's try to find the right one. Here it is. So here we're going to get one times one plus one times one. Minus one times one minus one times one minus one times one. We're going to get zero. But what about up here? Here we're going to get one times one plus one times one plus one times one. These do nothing because they're times zero minus one times zero. So we're going to get three. So we're only going to get three, the highest possible number in the situation where these are all as black as possible, or in this case as red as possible, and these are all white. And so that's only going to happen at a horizontal edge. So the one underneath that does exactly the same thing, exactly the same formulas. Oopsie daisy. The one underneath are exactly the same formulas. Three by three sliding thing here. But this time we've got a different matrix, different little mini matrix of coefficients, which is all ones going down and all minus ones going down. And so for exactly the same reason, this will only be three in situations where they're all one here and they're all zero here. So you can think of a convolution as being a sliding window of little mini dot products of these little three by three matrices. And they don't have to be three by three. Right? You could have, we could just have easily done five by five, and then we'd have a five by five matrix of coefficients, or whatever, whatever size you like. So the size of this is called its kernel size. This is a three by three kernel for this convolution. So then, because this is deep learning, we just repeat the, we just repeat these steps again and again and again. So this is this layer I'm calling conv one, it's the first convolutional layer. So con two, it's going to be a little bit different because on con one, we only had a single channel input. It's just black and white or, you know, yeah, black and white, grayscale one channel. But now we've got two channels, we've got the, let's make it a little smaller so we can see better. We've got the horizontal edges channel and the vertical edges channel. And we'd have a similar thing in the first layer of its color would have a red channel, a green channel and blue channel. So now our, our filter, this is called the filter, this little mini matrix is called the filter. Our filter. Our filter now contains a three by three by depth two, or if you give one thing of another way to three by three kernels or one three by three by two kernel. And we basically do exactly the same thing, which is we're going to multiply each of these by each of these and sum them up. But then we do it for the second bit as well we multiply each of these by each of these and sum them up. And so that gives us, I think I just picked some random numbers here. Right, so this is going to now be something which can combine, sorry, the second one, the second set. So it's, sorry, each of the red ones, by each of the blue ones. That's here. Plus each of the green ones times each of the mauve ones. That's here. So this first filter is being applied to the horizontal edge detector. And the second filter is being applied to the vertical edge detector. And as a result, we can end up with something that combines features of the two things. And so then we can have a second channel over here, which is just a different bunch of convolutions for each of the two channels. This one times this one. Again, you can see the colors. So what we could do is if, you know, once we kind of get to the end, we'll end up as I'll show you how in a moment, we'll end up with a single. Set of 10 activations, one per. Number digit we're recognizing zero to nine, or in this case, I think we could just create one, you know, maybe we're just trying to recognize nothing but the number number seven or not the number seven. So we could just have one activation. And then we would back propagate through this using SGD in the usual way. And that is going to end up optimizing these numbers. So in this case, I manually put in the numbers I knew would create edge detectors in real life, you start with random numbers, and then you use SGD to optimize these parameters. Okay, so there's a few things we can do next. And I'm going to, I'm going to show you the way that was more common a few years ago, and then I'll explain some changes that have been made more recently. What happened a few years ago was we would then take these, these activations, which as you can see these activations now kind of in a grid pattern. And we would do something called max polling and Max Pauling is kind of like a convolution it's a sliding window. But this time as the sliding window goes across so you're up to here, we don't do a dot product over a filter. But instead we just take a maximum. So here just this is the maximum of these four numbers. And if we go across a little bit, this is the maximum of these four numbers go across a bit, go across a bit, and so forth. That goes off the edge. And you can see what happens when this is called a two by two Max Pauling. So you can see what happens with a two by two Max Pauling, we end up losing half of our activations on each dimension. So we're going to end up with only one quarter of the number of activations we used to have. And that's actually a good thing, because if we keep on doing convolution Max Paul convolution Max Paul, we're going to get fewer and fewer and fewer activations until eventually we'll just have one left, which is what we want. That's effectively what we used to do. But the other thing I mentioned is we didn't normally keep going until there's only one left. What we used to then do is we'd basically say, okay, at some point, we're going to take all of the activations that are left. And we're going to basically just do a dot product of those with a bunch of coefficients, not as a convolution, but just as a normal linear layer. And this is called the dense layer. And then we would add them all up. So we basically end up with their final big product of all of the Max Pauled activations by all of the weights. And we do that for each channel. And so that would give us our final activation. And as I say here, amnest would actually have 10 activations. So you'd have a separate set of weights for each of the digits you're predicting, and then soft Max after that. Okay, nowadays, we do things very slightly differently. Nowadays, we normally don't have Max Paul layers. But instead, what we normally do is when we do our sliding window, like this one here, we don't normally, let's go back to see. So when I go one to the right, so currently we're starting in cell column G, if I go one to the right, the next one is column H. And if I go one to the right, the next one starts in column I. So you can see it's sliding the window every every every three by three. Nowadays, what we tend to do instead is we generally skip one. So we would normally only look at every second. So we would after doing column I, we would skip columns J and would just go straight to column K. And that's called a stride to convolution. We do that both across the rows and down the columns. And what that means is every time we do a convolution, we reduce our effective kind of feature size grid size by two on each axis. So it reduces it by four in total. So that's basically instead of doing Max Pauling. And then the other thing that we do differently is nowadays we don't normally have a single dense layer at the end, a single matrix model play at the end. But instead what we do, we generally keep doing straight to convolutions. So each one's going to reduce the grid size by two by two. We keep going down until we've got about a seven by seven grid. And then we do a single pooling at the end and we don't normally do Max Paul. Nowadays, instead we do an average pool. So we average the, the activations of each one of the seven by seven features. This is actually quite important to know because if you think about what that means, it means that something like an image net style image detector is going to end up with a seven by seven grid size. So it's a seven by seven grid. Let's try to say, is this a bear? And in each of the parts of the seven by seven grid, it's basically saying, is there a bear in this part of the photo? Is there a bear in this part of the photo? Is there a bear in this part of the photo? And then to take the average of those 49 seven by seven predictions to decide whether there's a bear in the photo. That works very well. If it's basically a photo of a bear, right, because most, you know, if it's, if the bear is big and takes up most of the frame, then most of those seven by seven bits are bits of a bear. On the other hand, if it's a teeny tiny bear in the corner, then potentially only one of those 49 squares has a bear in it. And even worse, if it's like a picture of lots and lots of different things, only one of which is a bear. It could end up not being a great bear detector. And so this is where like the details of how we construct our model turn out to be important. And so if you're trying to find like just one part of a photo that has a small bear in it, you might decide to use average pool, sorry, maximum pooling instead of average pooling, because Max pooling will just say, I think this is a picture of a bear. If any one of those 49 bits of my grid has something that looks like a bear in it. So these are, you know, these are potentially important details which often get hand waved over. Although, you know, again, like the key thing here is that this is happening right at the very end, right, that that Max pool or that average pooling is a little bit more than the average pooling. And actually, fast AI handles this for you. We do a special thing, which we kind of independently invented. I think we did it first, which is we do both Max pool and average pool and we can cat let them together. We call that can cat pulling. And that has since been reinvented in at least one paper. And so that means that you don't have to think too much about it because we're going to try both for you, basically. So I mentioned that this is actually really just matrix modification. And to show you that, I'm going to show you some images created by a guy called Matthew Kleinsmith who did this actually I think this is in our very first ever course but I've been the part two first part two course. And he basically pointed out that in a certain way of thinking about it, it turns out that convolution is the same thing as a matrix model play so I want to show you how he shows this. He basically says okay, let's take this three by three image and a two by two kernel, containing the coefficients alpha beta gamma delta. And so in this as we slide the window over each of the colors. Each of the colors the model play together red by red plus green by green plus what is that orange by orange plus blue play blue gives you this. And so to put it another way algebraically p equals alpha times a plus beta times b, etc. And so then as we slide to this part. And so this is how we calculate a convolution using the approach we just described as a sliding window. But here's another way of thinking about it. I could say, okay, we've got all these different things a BCD FTH J. Let's put them all into a single vector. And then let's create a single matrix that has alpha alpha alpha alpha beta beta beta beta etc. And then if we do this matrix multiplied by this vector, we get this with these gray zeros in the appropriate places, which gives us this, which is the same as this. And so this shows that a convolution is actually a special kind of matrix modification. It's a matrix modification where there are some zeros that are fixed, and some numbers that are forced to be the same. Now in practice, it's going to be faster to do it this way. But it's a useful kind of thing to think about I think that just to realize like oh, it's just another of these special types of matrix. So, we have two special types of matrix modifications. Okay. I think. Well, let's look at one more thing. Because there was one other thing that we saw, and I mentioned we would look at in the tabular model, which is called dropout. And then we have a spreadsheet. If you go to the con example dropout page. You'll see we've actually got a little bit more stuff here. We've got the same input as before, and the same first convolution is before, and the same second convolution is before. And then we've got a bunch of random numbers. They're showing as between zero and one, but they're actually that's just because they're rounding off. They're actually random numbers between, you know, that floats between zero and one. So, here. We're then saying. If. So look. So way up here was we mean a bit. I've got a dropout factor. Let's change this to zero point five. So over here, this is something that says, if the random number in the equivalent place is greater than point five. Then one, otherwise zero. And so here's a whole bunch of ones and zeros. Now this thing here is called a dropout mask. Now what happens is we multiply over here. We multiply the dropout mask and we multiply it by our filtered image. And what that means is we end up with exactly the same image we started with. Here's the image we started with. But it's corrupted random bits of it has been deleted and based on the amount of dropout we use, so if we change it to say point two. Not very much of it's deleted at all, so it's still very easy to recognize. We also if we use lots of dropouts say point eight. It's almost impossible to see what the number was. And then we use this as the input to the next layer. So that seems weird. Why would we delete some data at random from our processed image from our activations after a layer of the convolutions? Well, the reason is that a human is able to look at this corrupted image and still recognize it's a seven. And the idea is that a computer should be able to as well. And if we randomly delete different bits of the activations. Each time. Then the computer is forced to learn. The underlying real representation rather than overfitting. You can think of this as data augmentation, but it's data augmentation not for the inputs, but data augmentation for the activations. So this is called a dropout layer. And so dropout layers are really helpful for avoiding overfitting. And you can decide how much you want to compromise between good generalization. So lack of so good, you know, avoiding overfitting versus getting something that works really well in the training data. And so the more dropout you use, the less good it's going to be on the training data, but the better it ought to generalize. And so this comes from a paper by Jeffrey Hinton's group quite a few years ago now. Russellins now at Apple, I think, and then Kojeski and Hinton went on to found Google brain. And to you can see here, they've got this picture of a like fully connected neural network, two layers, just like the one we built. And here look, they're kind of randomly deleting some of the activations and all that's left is these connections. And so there's a different bunch that's going to be deleted. And then there's a different bunch that's going to be deleted. And so I think this is an interesting point. So dropout, which is super important, was actually developed in a master's thesis. And it was rejected from the main neural networks conference, then called NIPS, now called NURIPS. And it's been being disseminated through through archive, which is a preprint server. And as it's just been pointed out on our chat that Iliya was one of the founders of OpenAI. I don't know what happened to NITI. I think he went to Google brain as well, maybe. So, you know, peer review is a very fallible thing in both directions. And it's great that we have preprint servers so we can read stuff like this, even if reviewers decide it's not worthy. It's been one of the most important papers ever. Okay. Now, I think that's given us a good tour now. We've really seen quite a few ways of dealing with input to a neural network, quite a few of the things that can happen in the middle of a neural network. We've already talked about rectified linear units, which is this one here, zero, if X is less than zero or X otherwise. These are some of the other activations you can use. Don't use this one, of course, because you end up with a linear model. But they're all just different functions. As should mention, like it turns out these don't matter very much. Basically, pretty much any nonlinearity works fine. So we don't spend much time talking about activation functions, even in part two of the course just a little bit. So, yeah, so we understand there are, there's our imports, they can be 100 encoded or embeddings, which is a compute computational shortcut. There are sandwich layers of matrix model plays and activation functions. The matrix model plays can sometimes be special cases, such as the convolutions or the embeddings. The output can go through some tweaking, such as the softmax, and then of course you've got the loss function, such as cross entropy loss, or means grid error, or mean absolute error. But, you know, it's not, there's nothing too crazy going on in there. So I feel like we've got a good sense now of like what goes inside, you know, a wide range of neural nets, you're not going to see anything too weird from here. And we've also seen a wide range of applications. So before you come back to do part two. You know, what now? And we're going to have a little session here and in fact one of the questions was what now. So this is quite, quite good. One thing I strongly suggest is if you've got this far. It's probably worth you investing your time in reading Radix book, which is meta learning. And so meta learning is very heavily based on the kind of teachings of fast AI over the last few years and is all about how to learn deep learning and learn pretty much anything. Yeah, because you know you've got to this point, you may as well know how to get to the next point as well as possible. And. The main thing you'll see that Radix talks about or one of the main things is, is practicing and writing. So if you've kind of zipped through the videos on, you know, two X and haven't done any exercises. You know, go back and watch the videos again, you know, a lot of the best students end up watching them two or three times. Probably more like three times. And, and actually go through and code as you watch, you know, and experiment. You know, right posts blog posts about what you're doing. Spend time on the forum, both helping others and seeing other people's answers to questions. Read the success stories on the forum and of people's projects to get inspiration for things you could try. One of the most important things to do is to get together with other people. For example, you couldn't do, you know, a zoom study group in fact on our discord, which you can find through our forum. There's always study groups going on, or you can create your own. You know, a study group to go through the book together. Yeah, and of course, you know, build stuff. And sometimes it's tricky to. Always be able to build stuff for work, because maybe there isn't, you're not quite in the right area or they're not quite ready to try out deep learning yet. But that's okay. Build some hobby projects, build some stuff just for fun or build some stuff that you're passionate about. Yeah, so it's really important to, to not just put the videos away and go away and do something else because you'll forget everything you've learned and you want to practice. So one of our community members went on to create an activation function, for example, which is mesh, which is now as Tunisian has just reminded me on our forums is now used in many of the state of the art networks around the world. Which is pretty cool. This is and he's now at Mila, I think a research one of the top research labs in the world. I wonder how that's doing. Let's have a look. Go to Google scholar. Nice 486 citations. They're doing great. All right, let's have a look at how our topic is going and pick out some of the highest ranked ama's. Okay. So the first one is from Lucas and actually maybe I should actually let's switch our view here. So our first ama is from Lucas and Lucas asks, how do you stay motivated? I often find myself overwhelmed in this field. There are so many new things coming up that I feel like I have to put so much energy just to keep my head above the waterline. Yeah, that's a very interesting question. I mean, I think Lucas, the important thing is to realize you don't have to know everything, you know, in fact, nobody knows everything. And that's okay. What people do is they take an interest in some some area and they follow that and they try and do their best the best job they can of of keeping up with some little sub area. And if your little sub area is too much to keep up on pick a sub sub area. Yeah, there's nothing like there's no need for it to be demotivating that there's a lot of people doing a lot of interesting work and a lot of different sub fields. That's cool. You know, it is to be kind of dull with up here, you know, but then there's only basically five labs in the world working on your own it's. And yeah, from time to time, you know, take a dip into other areas that maybe you're not following us closely. But when you're but when you're just starting out. You'll find that things are not changing that fast at all really, they can kind of look that way because people are always putting out press releases about their new tweaks. But fundamentally the stuff that is in the course now is not that different to what was in the course five years ago. The foundations haven't changed. And it's not that different in fact to the convolutional neural network that Jan LeCun used on MNIST back in 1996. It's, you know, the basic ideas I've described are forever, you know, the way the inputs work and the sandwiches of matrix, and the model applies and activation functions and the stuff you do to the final layer, you know, everything else is tweaks. And the more you learn about those basic ideas, the more you'll recognize those tweaks as simple little tricks that you'll be able to quickly get your head around. So then Lucas goes on to ask to order comment. Another thing that constantly bothers me is I feel the field is getting more and more skewed towards bigger and more computationally expensive models. I keep wondering if in some years now, I would still be able to train reasonable models with a single GPU, or if everything is going to require a compute cluster. Yeah, that's a great question. I get that a lot. But interestingly, you know, I've been teaching people machine learning and data science stuff for nearly 30 years. And I've had a variation of this question throughout. And the reason is that engineers always want to push the envelope in like the on the biggest computers they can find, you know, that's just this like fun thing engineers love to do. And by definition, they're going to get slightly better results than people doing exactly the same thing on smaller computers. So it always looks like, oh, you need big computers to be state of the art. But that's actually never true. Right, because there's always smarter ways to do things, not just bigger ways to do things. And so, you know, when you look at fast a eyes, Dawn bench success, when we trained image net faster than anybody had trained it before on standard GPUs, you know, me and a bunch of students. That was not meant to happen. You know, Google was working very hard with their TPU introduction to try to show how good they were Intel was using like 256 PCs and parallel or something. But yeah, you know, we used common sense and smarts and showed showed what can be done. You know, it's also a case of picking the problems you solve. So I would not be probably doing like going head to head up against codecs and trying to create code from English descriptions. You know, because that's that's a problem that does probably require very large neural nets and very large amounts of data. But if you pick areas in different domains, you know, there's still huge areas where much smaller models are still going to be state of the art. So hopefully that helped answer your question. Let's see what else we got here. So Daniel, as I was saying, following my journey with teaching my daughter, math. He's so I homeschool my daughter. And Daniel asks, how do you homeschool young children science in general and math in particular. Would you share your experiences by blogging or lectures someday. So I could do that. So I actually spent quite a few months just reading research papers about education recently. So I do probably have a lot I probably need to talk about at some stage. But yeah, broadly speaking. I lean into using computers and tablets a lot more than most people, because actually there's an awful lot of really great apps that are super compelling. They're adaptive so they go at the right speed for the student and they're fun. And I really like my daughter to have fun. You know, I really don't like to force her to do things. For example, there's a really cool app called dragon box algebra five plus, which teaches algebra to five year olds by using a really fun computer game involving helping dragon eggs to hatch. And it turns out that yeah, algebra, the basic ideas of algebra are no more complex than the basic ideas that we do in other kindergarten math. And all the parents I know of who've given their kids dragon box algebra five plus their kids have successfully learned algebra. So that would be an example. But yeah, we should talk about this more at some point. Alright, let's see what else we've got here. So far, says the walkthroughs have been a game changer for me. The knowledge and tips you shared in those sessions are skills required to become an effective machine learning practitioner and utilize faster, more effectively. Have you considered making the walkthroughs a more formal part of the course doing a separate software engineering course or continuing live coding sessions between part one and two. So yes, I am going to keep doing live coding sessions. At the moment we've switched to those specifically to focusing on a PL. And then in a couple of weeks they're going to be going to fast study groups. And then after that they'll gradually turn back into more live coding sessions. But yeah, the thing I try to do in my live coding or study groups, whatever is definitely try to show the foundational techniques that just make life. Easier as a coder or a data scientist. When I say foundational, I mean, yeah, the stuff which you can reuse again and again and again, like learning regular expressions really well or knowing how to use VM or understanding how to use the terminal and command line, you know, all that kind of stuff. Never goes out of style, it never gets old. And yeah, I do plan to. At some point, hopefully actually do a course really all about that stuff specifically. But yeah, for now, for now the best approaches follow along with the live coding and stuff. Okay, WG pubs, which is Wade asks, how do you turn a model into a business. So, you know, the other coder with a little or no startup experience turn an ML based radio prototype into a legitimate business venture. Okay, I plan to do a course about this at some point as well. So, you know, obviously there isn't a two minute version to this but the key thing with creating a legitimate business venture is to solve a legitimate problem. You know, a problem that people need solve solving and which they will pay you to solve. And so it's important not to start with your fun radio prototype as a basis your business, but instead start with here's a problem I want to solve. And generally speaking, you should try to pick a problem that you understand better than most people. So it's either a problem that you face day to day in your work or in some hobby or passion that you have or that, you know, your club has or your local score has or your, your spouse deals with in their workplace. You know, it's something where you understand that there's a something that doesn't work as well as it ought to. Particularly something where you think yourself, you know, if they just used deep learning here or some algorithm here or some better compute here. That problem would go away. And that's that's the start of a business. And then my friend Eric Rees wrote a book called the lean startup where he describes what you do next, which is basically you fake it. You create. So he calls it the minimum viable product. You create something that solves that problem. It takes you as little time as possible to create. It could be very manual. It can be loss making. It's fine. The bit in the middle where you're like, Oh, there's going to be a neural net here. It's fine to like launch without the neural net and do everything by hand. You're just trying to find out if people going to pay for this and this is actually useful. And then once you have, you know, hopefully confirmed that the need is real and that people will pay for it and you can solve the needs. You can gradually make it less and less of a fake, you know, and do, you know, more and more. Product to where you want it to be. Okay, I don't know how to pronounce the name M i w j c. And my w jc says Jeremy, can you share some of your productivity hacks from the content you produce it may seem you worked 24 hours a day. I certainly don't do that. I think one of my main productivity hacks actually is not to work too hard. Or at least not to work too hard, not to work too much. I spent probably less hours a day working than most people, I would guess. But I think I do a couple of things differently when I'm working. I've spent half at least half of every working day since I was about 18 learning or practicing something new. Could be a new language could be a new algorithm could be something I read about. And nearly all of that time, therefore I've been doing that thing. More slowly than I would if I just use something I already knew. Which often drives my co workers crazy because they're like, you know, why aren't you focusing on getting that thing done. But in the other 50% of the time. I'm constantly, you know, building up this kind of exponentially improving. And I'm a very invasive expertise in a wide range of areas. And so now I do find, you know, I can do things often orders of magnitude faster than people around me or certainly many multiples faster than people around me because I, you know, know a whole bunch of tools and skills and ideas which. Yeah, no other people don't necessarily know so I think that's one thing that's been helpful and then another is yeah like trying to really not overdo things like get good sleep and eat well and exercise well. And also I think it's a case of like tenacity, you know, I've noticed a lot of people give up much earlier than I do. So yeah, if you. If you just keep going until something's actually finished. Then that's going to put you in a small minority, to be honest, most people don't do that when I say finished like finish something really nicely. And I try to make it like so I'm particularly like coding and so I try to do a lot of coding related stuff. So I create things like Nbdev and Nbdev makes it much, much easier for me to finish something nicely. You know, so in my kind of chosen area I've spent quite a bit of time trying to make sure it's really easy for me to like get out a blog post, get out a Python library, get out a notebook analysis, whatever. So yeah, trying to make these things I want to do easier and so then I'll do them more. So, well thank you everybody. That's been a lot of fun. Really appreciate you taking the time to go through this course with me. Yeah, if you enjoyed it, it would really help if you would give a like on YouTube, because it really helps other people find the course goes into the YouTube recommendation system. And please do come and help other beginners on forums.fast.ai. It's a great way to learn yourself is to try to teach other people. And yeah, I hope you'll join us in in part two. Thanks everybody very much. I really enjoyed this process and I hope to get to meet more of you in person in the future. Bye.
