 Welcome to practical deep learning for coders lesson one. This is version five of this course. And it's the first do one we've done in two years. So we've got a lot of cool things to cover. It's amazing how much has changed. Here is a XKCD from the end of 2015. Who here is saying XKCD comics before? Pretty much everybody, not surprising. So the basic joke here is I'll let you read it, and then I'll come back to it. So it can be hard to tell what's easy and what's nearly impossible. And in 2015 or at the end of 2015, the idea of checking whether something is a photo of a bird was considered nearly impossible. So impossible, it was the basic idea of a joke, because everybody knows that that's nearly impossible. We're now going to build exactly that system for free in about two minutes. So let's build an Is It a Bird system? So we're going to use Python. And so I'm going to run through this really quickly. You're not expected to run through it with me, because we're going to come back to it. But let's go ahead and run that cell. So what we're doing is we're searching DuckDuckGo for images of bird photos. And we're just going to grab one. And so here is the URL of the bird that we grabbed. OK, we're going to download it. OK, so there it is. So we've grabbed a bird. And so OK, we've now got something that can download pictures of birds. Now, we're going to need to build a system that can recognize things that are birds versus things that aren't birds from photos. Now, of course, computers need numbers to work with. But luckily, images are made of numbers. I actually found this really nice website called Pics by where I can grab a bird. And if I go over it, let's pick its beak. You'll see here that that part of the beak was 251 brightness of red, 48 of green, and 21 of blue. So that's G, B. And so you can see as I wave around, those colors are changing, those numbers. And so this picture, the thing that we recognize as a picture, is actually 256 by 171 by three numbers between 0 and 255, representing the amount of red, green, and blue on each pixel. So that's going to be an input to our program. It's going to try and figure out whether this is a picture of a bird or not. OK. So let's go ahead and run this cell, which is going to go through. And I needed bird and nonbird, but you can't really search Google images or dap, dap, dap, go images for not a bird. This doesn't work that way. So I just decided to use forest. I thought, OK, pictures of forest versus pictures of bird sounds like a good starting point. So I go through each of forest and bird, and I search for forest photo and bird photo, download images, and then resize them to be no bigger than 400 pixels on a side, just because we don't need particularly big ones. It takes a surprisingly large amount of time to just recompute it open an image. OK, so we've now got 200 of each. I find when I download images, I often get a few broken ones. And if you try and train a model with broken images, it will not work. So here's something which just verifies each image and unlinks. So it's the ones that don't work. OK, so now we can create what's called a data block. So after I run this cell, you'll see that basically, I'll go through the details of this later. But a data block gives fast AI, the library, all the information it needs to create a computer vision model. And so in this case, we're basically telling it, get all the image files that we just downloaded. And then we say, show me a few, up to six. And let's see. So we've got some birds, forest, bird, bird, forest. OK, so one of the nice things about doing computer vision models is it's really easy to check your data, because you can just look at it, which is not the case for a lot of kinds of models. OK. So we've now downloaded 200 pictures of birds, 200 pictures of forests. So we're now press run. And this model is actually running on my laptop. So this is not using a vast data center. It's running on my presentation laptop. And it's doing it at the same time as my laptop is streaming video, which is possibly a bad idea. And so what it's going to do is it's going to run through every photo out of those 400. And for the ones that are forest, it's going to learn a bit more about what forest looks like. And for the ones that are bird, it'll learn a bit more about what bird looks like. So overall, it took under 30 seconds. And believe it or not, that's enough to finish doing the thing, which was in that XKCD comic. Let's check by passing in that bird that we downloaded at the start. This is a bird. Probability is a bird. One. Rounded to the nearest four decimal places. So something pretty extraordinary has happened since late 2015, which is literally something that has gone from so impossible, it's a joke, to so easy that I can run it on my laptop computer in I don't know how long it was, about two minutes. And so hopefully that gives you a sense that creating really interesting real working programs with deep learning is something that it doesn't take a lot of code, didn't take any math, didn't take more than my laptop computer. It's pretty accessible, in fact. So that's really what we're going to be learning about over the next seven weeks. So where have we got to now with deep learning? Well, it moves so fast, but even in the last few weeks, we've taken it up another notch as a community. You might have seen that something called Dali 2 has been released, which uses deep learning to generate new pictures. And I thought this was an amazing thing that this guy, Nick, did, where he took his friends Twitter bios and typed them into the Dali 2 input, and it generated these pictures. So this guy's, he typed in commitment, sympathetic, psychedelic, philosophical, and it generated these pictures. So I'll just show you a few of these. I'll actually read them. I love that. That one's pretty amazing, I reckon, actually. I love this. Happy Sisyfus has actually got a happy rock to move around. So this is like, yeah, I don't know. When I look at these, I still get pretty blown away that this is a computer algorithm using nothing but this text input to generate these arbitrary pictures. In this case, it's fairly complex and creative things. So the guy who made those points out, this is like he spends about two minutes or so creating each of these. Like he tries a few different prompts, and he tries a few different pictures. And so he's given an example here of what he types something into the system. Here's an example of 10 different things. He gets back when he puts in expressive painting of a man shining rays of justice and transparency on a blue bird Twitter logo. So it's not just Dali 2, to be clear. There's a lot of different systems doing something like this now. There's something called mid journey, which this Twitter account posted a female scientist with a laptop writing code in a symbolic, meaningful, and vibrant style. This one here is an HD photo of a rare psychedelic pink elephant. And this one, I think, is the second one here. I never know how to actually pronounce this. This one's pretty cool. A blind bat with big sunglasses holding a walking stick in its hand. And so when actual artists, so for example, this guy said, he knows nothing about art. He's got no artistic talent. It's just something he threw together. This guy is an artist who actually writes his own software based on deep learning and spends months on building stuff. And as you can see, you can really take it to the next level. It's been really great, actually, to see how a lot of fast AI alumni with backgrounds, as artists, have gone on to bring deep learning and art together. And it's a very exciting direction. And it's not just images to be clear. One of another interesting thing that's popped up in the last couple of weeks is Google's Pathways Language Model, which can take any arbitrary English as text question and can create an answer, which not only answers the question, but also explains its thinking, whatever it means for a language model to be thinking. One of the ones I found pretty amazing was that it can explain a joke. I'll let you read this. So this is actually a joke that probably needs explanations. Anybody who's not familiar with TPUs, so this model just took the text as input and created this text as output. And so you can see, again, deep learning models, doing things which I think very few, if any of us would have believed, would be maybe possible to do by computers even in our lifetime. This means that there is a lot of practical and ethical considerations. We will touch on them during this course, but can't possibly hope to do them justice. So I would certainly encourage you to check out ethics.fast.ai to see our whole data ethics course taught by my cofounder, Dr. Rachel Thomas, which goes into these issues in a lot more detail. All right, so as well as being an AI researcher at the University of Queensland and Fast.ai, I am also a homeschooling primary school teacher. And for that reason, I study education a lot. And one of the people who are live in education is a guy named Dylan Williams. And he has this great approach in his classrooms of figuring out how his students are getting along, which is to put a colored cup on their desk, green, to mean that they're doing fine, yellow cup to mean I'm not quite sure in a red cup to mean I have no idea what's going on. Now, since most of you are watching this remotely, I can't look at your caps. And I don't think anybody bought colored cups with them today. So instead, we have an online version of this. So what I want you to do is go to cups.fast.ai slash fast. That's cups.fast.ai slash fast. And don't do this if you're a fast AI expert who's done the course five times. Because if you're following along, that doesn't really be much. I would say this is really for people who are not already fast AI experts. And so click one of these colored buttons. And what I will do is I will go to the teacher version and see what buttons you're pressing. All right. So so far, people are feeling we're not going too fast on the whole. We've got one. Nope. One brief read. OK. So hey, Nick, this URL is the same thing with teacher on the end. If you can you keep that open as well and let me know if it suddenly gets covered in red. If you ask somebody who's read, I'm not going to come to you now because there's not enough of you to stop the class. So it's up to you to ask on the forum or on the YouTube live chat. And there's a lot of folks, luckily, who will be able to help you. All right. I wanted to do a big shout out to Radik. Radik created cups.fast.ai for me. I said to him last week, I'd eat away of seeing colored cups on the internet. And he wrote it in one evening. And I also wanted to shout out that Radik just announced today that he got a job at NVIDIA AI. And I wanted to say that fast AI alumni around the world very, very frequently, like every day or two, they may want me to say that they've got their dream job. And yeah, if you're looking for inspiration of how to get into the field, I couldn't recommend nothing. Nothing would be better than checking out Radik's work. And he's actually written a book about his journey. It's got a lot of tips in particular about how to take advantage of fast AI, make the most of these lessons. And so I would certainly check that out as well. And if you're here live, he's one of our TAs as well. So you can say hello to him afterwards. He looks exactly like this picture here. So I mentioned I spent a lot of time studying education, both for my homeschooling duties and also for my courses. And you'll see that there's something a bit different, very different about this course, which is that we started by training a model. We didn't start by doing a in depth review of linear algebra and calculus. That's because two of my favorite writers and researchers on education, Paul Lockhart and David Perkins, and many others talk about how much better people learn when they learn with a context in place. So the way we learn math at school, where we do like counting and then adding and then fractions and then decimals and then blah, blah, blah. And 15 years later, we start doing the really interesting stuff at grad school. That is not the way most people learn effectively. The way most people learn effectively is from the way we teach sports, for example, where we show you a whole game of sports, we show you how much fun it is, you go and start playing sports, simple versions of them, you're not very good, right? And then you gradually put more and more pieces together. So that's how we do deep learning. You will go into as much depth as the most sophisticated, technically detailed classes you'll find later, right? But first, you'll learn to be very, very good at actually building and deploying models. And you will learn why and how things work as you need to to get to the next level. For those of you that have spent a lot of time in technical education, like if you've done a PhD or something, you'll find this deeply uncomfortable because you'll be wanting to understand why everything works from the start. Just do your best to go along with it. Those of you who haven't, we'll find this very natural. Oh, and this is Dylan Williams, who I mentioned before, the guy who came up with a really cool cup of sing. There'll be a lot of tricks that have come out of the educational research literature scattered through this course. On the whole, I won't call them out, they'll just be there. But maybe from time to time, we'll talk about them. All right, so before we start talking about how we actually built that model and how it works, I guess I should convince you that I'm worth listening to. I'll try to do that reasonably quickly because I don't like turning my own horn, but I know it's important. So the first thing I mentioned about me is that me and my friend, Stolve, wrote this extremely popular book, Deep Learning for Coders, and that book is what this course is quite heavily based on. We're not going to be using any material from the book directly, and you might be surprised by that. But the reason actually is that the educational research literature shows that people learn things best when they hear the same thing in multiple different ways. So I want you to read the book, and you'll also see the same information presented in a different way in these videos. So one of the bits of homework after each lesson will be to read the chapter of the book. A lot of people like the book. Peter Norvig, Director of Research, loves the book, in fact, who's one's here, one of the best sources for a program to become proficient in deep learning. Eric Topol loves the book. Hal Varian, Emeritus Professor at Berkeley, Chief Columns at Google likes the book. Jerome Pessente, who is the head of AI at Facebook likes the book. A lot of people like the book. So hopefully you'll find that you left this material as well. I've spent about 30 years of my life working in and around machine learning, including building a number of companies that relied on it. And became the highest ranked competitor in the world on Kaggle in machine learning competitions. My company in Liddick, which I founded, was the first company to specialize in deep learning for medicine. And MIT voted at one of the 50 smartest companies in 2016, just above Facebook and SpaceX. I started Fast AI with Rachel Thomas. And that was quite a few years ago now, but it's had a big impact on the world already, including work we've done with our students has been globally recognized, such as our wind in the Dawnbench competition, which showed how we could train big neural networks faster than anybody in the world, and cheaper than anybody in the world. And so that was a really big step in 2018, which actually made a big difference. Google started using our special approaches in their models. Nvidia started optimizing their stuff using our approaches. So it made quite a big difference there. I'm the inventor of the ULM fit algorithm, which according to the Transformers book, was one of the two key foundations behind the modern NLP revolution. This is the paper here. And actually, interesting point about that, it was actually invented for a Fast AI course. So the first time it appeared was not actually in the journal. It was actually in lesson four of the course. I think the 2016 course, if I remember correctly. And most importantly, of course, I've been teaching this course since version one. And this is actually the, I think this is the very first version of it, which even back then was getting HBR's attention. A lot of people have been watching the course, and it's been really widely used. YouTube doesn't show likes anymore, so I have to show you our likes for you. It's been amazing to see how many alumni have gone from this to really doing amazing things. And so for example, Andre Kapathy told me that Tesla, I think he said pretty much everybody who joins Tesla and AI is meant to do this course. I believe in open AI, they told me that all the residents joining there first do this course. So this course is really widely used in industry and research for people, and they have a lot of success. OK, so there's a bit of brief information about why you should hopefully keep going with this. All right, so let's get back to what's happened here. Why are we able to create a bird recognizer in a minute or two? And why couldn't we do it before? So I'm going to go back to 2012. And in 2012, this was how image recognition was done. This is the computational pathologist. It was a project done at Stanford. Very successful, very famous project that was looking at the five year survival of breast cancer patients by looking at their histopathology images slides. Now, so this is what I would call a classic machine learning approach. And I spoke to the senior author of this, Daphne Collar. And I asked her why they didn't use deep learning. And she said, well, it wasn't really on the radar at that point. So this is like a free deep learning approach. And so the way they did this was they got a big team of mathematicians and computer scientists and pathologists and so forth to get together and build these ideas for features, like relationships between epithelial and nuclear neighbors. Thousands and thousands, actually, they created a feature. And each one required a lot of expertise from a cross disciplinary group of experts at Stanford. So this project took years and a lot of people and a lot of code and a lot of math. And then once they had all these features, they then fed them into a machine learning model, in this case, logistic progression to predict survival. As I say, it's very successful. But it's not something that I could create for you in a minute at the start of a course. The difference with neural networks is neural networks don't require us to build these features. They build them for us. And so what actually happened was, in I think it was 2015, Matt Zyla and Rob Fergus took a trained neural network and they looked inside it to see what it had learned. So we don't give it features, we ask it to learn features. So when Zyla and Fergus looked inside a neural network, they looked at the actual weights in the model and they drew a picture of them. And this was nine of the sets of weights they found. And this set of weights, for example, finds diagonal edges. This set of weights finds yellow to blue gradients. And this set of weights finds red to green gradients. And so forth. And then down here are examples of some bits of photos, which closely matched, for example, this feature detector. And deep learning is deep because we can then take these features and combine them to create more advanced features. So these are some layer two features. So there's a feature, for example, that finds corners and a feature that finds curves and a feature that finds circles. Now, here are some examples of bits of pictures that the circle finder found. And so remember, with a neural net, which is the basic function used in deep learning, we don't have to hand code any of these or come up with any of these ideas. You just start with actually a random neural network and you feed it examples and you have a learn to recognize things. And it turns out that these are the things that it creates for itself. So you can then combine these features. And when you combine these features, it creates a feature detector, for example, that finds kind of repeating geometric shapes. And it creates a feature detector, for example, that finds kind of really little things, which it looks like, is finding the edges of flowers. And this feature detector here seems to be finding words. And so the deeper you get, the more sophisticated the features it can find are. And so you can imagine that trying to code these things by hand would be insanely difficult and you wouldn't know even what to encode by hand. So what we're going to learn is how neural networks do this automatically. But this is the key difference of why we can now do things that previously we just didn't even conceive of as possible. Because now we don't have to hand code the features we look for. They can all be learned. Now, in order to recognize, we're going to be spending some time learning about building image based algorithms. And image based algorithms are not just for images. And in fact, this is going to be a general theme. We're going to show you some foundational techniques. But with creativity, these foundational techniques can be used very widely. So for example, an image recognizer can also be used to classify sounds. So this was an example from one of our students who posted on the forum and said for their project, they would try classifying sounds. And so they basically took sounds and created pictures from their waveforms. And then they used an image recognizer on that. And they got a state of the art result, by the way. Another of our students on the forum said that they did something very similar to take time series and turn them into pictures and then use image classifiers. Another of our students created pictures from mouse movements, from users of a computer system. So the clicks became dots and the movements became lines. And the speed of the movement became colors. And then use that to create an image classifier. So you can see with some creativity, there's a lot of things you can do with images. There's something else I wanted to point out, which is that as you saw, when we trained a real working bird recognizer image model, we didn't need lots of math. There wasn't any. We didn't need lots of data. We had 200 pictures. We didn't need lots of expensive computers. We just used my laptop. This is generally the case for the vast majority of deep learning that you'll need in real life. There will be some math that pops up during this course. But we will teach it to you as needed or we'll refer you to external resources as needed. But it will just be the little bits that you actually need. The myth that deep learning needs lots of data, I think, has mainly passed along by big companies that want to sell you computers to store lots of data and to process it. We find that most real world projects don't need extraordinary amounts of data at all. And as you'll see, there's actually a lot of fantastic places you can do state of the artwork for free nowadays, which is great news. One of the key reasons for this is because of something called transfer learning, which we'll be learning about a lot during this course. And it's something which very few people are aware of, a pair of. In this course, we'll be using PyTorch. For those of you who are not particularly close to the deep learning world, you might have heard of TensorFlow and not of PyTorch. You might be surprised to hear that TensorFlow has been dying in popularity in recent years. And PyTorch is actually growing rapidly. And in research repositories amongst the top papers, TensorFlow is a tiny minority now compared to PyTorch. This is also great research that's come out from Ryan Ocona. He also discovered that the majority of people that were doing TensorFlow in 2018, researchers, the majority have now shifted to PyTorch. And I mentioned this because what people use in research is a very strong leading indicator of what's going to happen in industry, because this is where all the new algorithms are going to come out. This is where all the papers are going to be written about. It's going to be increasingly difficult to use TensorFlow. We've been using PyTorch since before it came out, before the initial release, because we knew just from technical fundamentals, it was far better. So this course has been using PyTorch for a long time. I will say, however, that PyTorch requires a lot of hairy code for relatively simple things. This is the code required to implement a particular optimizer, called Adam W, in plain PyTorch. I actually copied this code from the PyTorch repository. So as you can see, there's a lot of it. This gray bit here is the code required to do the same thing with Fast.AI. Fast.AI is a library we built on top of PyTorch. This huge difference is not because PyTorch is bad. It's because PyTorch is designed to be a strong foundation to build things on top of, like Fast.AI. So when you use Fast.AI, the library, you get access to all the power of PyTorch as well. But you shouldn't be writing all this code if you only need to write this much code. The problem of writing lots of code is that that's lots of things to make mistakes with, lots of things to not have best practices in, lots of things to maintain. In general, we found particularly with deep learning, less code is better. Particularly with Fast.AI, the code you don't write is code that we've basically found best practices for you. So when you use the code that we've provided for you, you're generally fine to get better results. So Fast.AI has been a really popular library, and it's very widely used in industry, in academia, and in teaching. And as we go through this course, we'll be seeing more and more pure PyTorch as we get deeper and deeper underneath to see exactly how things work. The Fast.AI library just won the 2020 Best Paper Award, or the paper about it, in information. So again, you can see it's very well regarded library. OK. So OK, we're still green. That's good. So you may have noticed something interesting, which is that I'm actually running code in these slides. That's because these slides are not in PowerPoint. These slides are in. Jupyter Notebook. Jupyter Notebook is the environment in which you will be doing most of your computing. It's a web based application, which is extremely popular and widely used in industry, and in academia, and in teaching. And it's a very, very, very powerful way to experiment and explore and to build. Nowadays, I would say most people, at least most students, run Jupyter Notebooks not on their own computers, particularly for data science, but on a cloud server, of which there's quite a few. And as I mentioned earlier, if you go to cost.fast.ai, you can see how to use various different cloud servers. One I'm going to show an example of is Kaggle. So Kaggle doesn't just have competitions, but it also has a cloud Notebooks server. And I've got quite a few examples there. So let me give you a quick example of how we use Jupyter Notebooks to build stuff, to experiment, to explore. So on Kaggle, if you start with somebody else's Notebook, so why don't you start with this one, Jupyter Notebook 101. If it's your own Notebook, you'll see a button called edit. If it's somebody else's, that button will say copy and edit. If you use somebody's Notebook that you like, make sure you click the upvote button to encourage them and to help other people find it before you go ahead and copy and edit. And once we're in edit mode, we can now use this Notebook. And to use it, we can type in any arbitrary expression in Python and click run. And the very first time we do that, it says session is starting, it's basically launching a virtual computer for us to run our code. This is all free. In a sense, it's like the world's most powerful calculator. It's a calculator where you have all of the capabilities of the world's, I think, most popular programming language, certainly in JavaScript would be the top two, directly at your disposal. So Python does know how to do one plus one. And so you can see here it spits out the answer. I hate clicking. I always use keyboard shortcuts. So instead of clicking this little arrow, you just press shift enter to do the same thing. But as you can see, there's not just calculations here. There's also pros. And so Jupyter Notebook's so great for explaining to you the version of yourself in six months time, what on earth you are doing or to your coworkers, or to people in the open source community, or to people you're blogging for, et cetera. And so you just type pros. And as you can see, when we create a new cell, you can create a code cell, which is a cell that lets you type calculations, or a markdown cell, which is a cell that lets you create pros. And the pros use this formatting in a little menu language called markdown. There's so many tutorials around. I won't explain it to you. But it lets you do things like links and so forth. So I'll let you follow through the tutorial in your own time, because it really explains to you what to do. One thing to point out is that sometimes you'll see me use cells with an exclamation mark at the start. That's not Python. That's a bash shell command. So that's what the exclamation mark means. As you can see, you can put images into notebooks. And so the image I popped in here was the one showing that Jupyter won the 2017 Software System Award, which is pretty much the biggest award there is for this kind of software. So that's the basic idea of how we use notebooks. So let's have a look at how we do our bird or not bird model. One thing I always like to do when I'm using something like Colab or Kaggle, Cloud Platforms that I'm not controlling is make sure that I'm using the most recent version of any software. So my first cell here is exclamation mark pip install minus u. That means upgrade, queue for quiet, fast di. So that makes sure that we have the latest version of fast di. And if you always have that at the start of your notebooks, you're never going to have those awkward foreign threads where you say, why isn't this working? And somebody says to you, oh, you're using an old version of some software. So you'll see here this notebook is the exact thing that I was showing you at the start of this lesson. So if you haven't done much Python, you might be surprised about how little code there is here. And so Python is a concise, but not too concise language. You'll see that there's less boilerplate than some other languages you might be familiar with. And I'm also taking advantage of a lot of libraries. So fast di provides a lot of convenient things for you. So I got to import. So to use an external library, we use import to import a symbol from a library. Fast di has a lot of libraries we provide. They generally start with fast something. So for example, to make it easy to download a URL, fast download has download URL. To make it easy to create a thumbnail, we have image to thumb and so forth. So I always like to view, as I'm building a model, my data at every step. So that's why I first of all grab one bird. And then I grab one forest photo, and I look at them to make sure they look reasonable. And once I think, OK, they look OK, then I go ahead and download. And so you can see, fast di has a download images where you just provide a list of URLs. So that's how easy it is. And it does that in parallel. So it does that surprisingly quickly. One other fast thing I think I'm using here is resize images. You generally will find that for computer vision algorithms, you don't need particularly big images. So I'm resizing these to a maximum size length of 400, because it's actually much faster. Because GPU is so quick, for big images, most of the time can be taken up just opening it the neural net itself often takes less time. So that's another good reason to make them smaller. OK, so the main thing I wanted to tell you about was this data block command. So the data block is the key thing that you're going to want to get familiar with as deep learning practitioners at the start of your journey. Because the main thing you're going to be trying to figure out is how do I get this data into my model? Now that might surprise you. You might be thinking we should be spending all of our time talking about neural network architectures and matrix modification and gradients and stuff like that. The truth is very little of that comes up in practice. And the reason is that at this point, the deep learning as community has found a reasonably small number of types of model that work for nearly all the main applications you'll need. And first, I will create the right type of model for you, the vast majority of the time. So all of that stuff about tweaking neural network architectures and stuff, I mean, we'll get to it eventually in this course. But you might be surprised to discover that it almost never comes up. Kind of like if you ever did a computer science course or something and they spent all this time on the details of compilers and operating systems, and then you get to the real world and you never use it again. So this course is called practical deep learning. And so we're going to focus on the stuff that is practically important. OK, so our image is finished downloading. And two of them were broken, so we just deleted them. Another thing you'll note, by the way, if you're a cane software engineer is I tend to use a lot of functional style in my programs. I find for the kind of work I do that a functional style works very well. If you're a lot of people in Python or less familiar with that, it maybe comes more from other things. So that's why you'll see me using stuff like math and stuff quite a lot. All right, so a data block is the key thing you need to know about if you're going to know how to use different kinds of data sets. And so these are all of the things, basically, that you'll be providing. And so what we did when we designed the data block was we actually looked and said, OK, over hundreds of projects, what are all the things that change from project to project to get the data into the right shape? And we realized we could basically split it down into these five things. So the first thing that we tell Fast.DI is what kind of input do we have? And so there are lots of blocks in Fast.DI for different kinds of inputs. So we said, oh, the input is an image. What kind of output is there? What kind of label? The outputs are category. So that means it's one of a number of possibilities. So that's enough for Fast.DI to know what kind of model to build for you. So what are the items in this model? What am I actually going to be looking at to train from? This is a function. In fact, you might have noticed, if you were looking carefully, that we use this function here. It's a function which returns a list of all of the image files in a path based on extension. So every time it's going to try and find out what things to train from, it's going to use that function. In this case, we'll get a list of image files. Now, something we'll talk about shortly is that it's critical that you put aside some data for testing the accuracy of your model. And that's called a validation set. It's so critical that Fast.DI won't let you train a model without one. So you actually have to tell it how to create a validation set, how to set aside some data. And in this case, we say randomly set aside 20% of the data. OK. Next question, then you have to tell Fast.DI, is how do we know the correct label of a photo? How do we know if it's a bird photo or a forest photo? And this is another function. And this function simply returns the parent folder of a path. And so in this case, we saved our images into either forest or bird. So that's where the labels are going to come from. And then finally, most computer vision architectures need all of your inputs as you train to be the same size. So item transforms are all of the bits of code that are going to run on every item, on every image in this case. And we're saying, OK, we want you to resize each of them to being 192 by 192 pixels. There's two ways you can resize. You can either crop out a piece in the middle, or you can squish it. And so we're saying squish it. So that's the data block. That's all that you need. And from there, we create an important class called data loaders. Data loaders are the things that actually PyTorch iterates through to grab a bunch of your data at a time. The way it can do it so fast is by using a GPU, which is something that can do thousands of things at the same time. And that means it needs thousands of things to do at the same time. So a data loader will feed the training algorithm with a bunch of your images at once. In fact, we don't call it a bunch. We call it a batch or a mini batch. And so when we say show batch, that's actually a very specific word. And deep learning, it's saying show me an example of a batch of data that you would be passing into the model. And so you can see show batch gives you tells you two things, the input, which is the picture, and the label. And remember, the label came by calling that function. So when you come to building your own models, you'll be wanting to know what kind of splitters are there, and what kinds of labeling functions are there, and so forth. What's wrong button? You'll be wanting to know what kind of labeling functions are there, and what kind of splitters are there, and so forth. And so DocStopFast.ai is where you go to get that information. Often the best place to go is the tutorials. So for example, here's a whole data block tutorial. And there's lots and lots of examples. So hopefully you can start out by finding something that's similar to what you want to do and see how we did it. But then of course, there's also the underlying API information. So here's data blocks. OK. How are we doing? Still doing good. All right. So at the end of all this, we've got an object called dls, it's down for data loaders. And that contains iterators that PyTorch can run through to grab batches of randomly split out, training images to train the model with, and validation images to test the model with. So now we need a model. The critical concept here in Fast.AI is called a learner. A learner is something which combines a model, which is that is the actual neural network function we'll be training, and the data we use to train it with. And that's why you have to pass in two things. The data, which is the data loaders object, and a model. And so the model is going to be the actual neural network function that you want to pass in. And as I said, there's a relatively small number that basically work for the vast majority of things you do. If you pass in just a bare symbol like this, it's going to be one of Fast.AI's built in models. But what's particularly interesting is that we integrate a wonderful library by Ross Weitman called Tim, the PyTorch image models, which is the largest collection of computer vision models in the world. And at this point, Fast.AI is the first and only framework to integrate this. So you can use any one of the PyTorch image models. And one of our students, Amana Mora, was kind enough to create this fantastic documentation where you can find out all about the different models. And if we click on here, you can get lots and lots of information about all the different models that Ross has provided. Having said that, the model family called ResNet are probably going to be fine for nearly all the things you want to do. But it is fun to try different models out. So you can type in any string here to use any one of those other models. OK, so if we run that, let's see what happens. OK, so this is interesting. So when I ran this, so remember on Kaggle, it's creating a new virtual computer for us. So it doesn't really have anything ready to go. So when I ran this, the first thing it did was it said downloading ResNet18.pth. What's that? Well, the reason we can do this so fast is because somebody else has already trained this model to recognize over 1 million images of over 1,000 different types, something called the ImageNet Dataset. And they then made those weights available, those parameters available on the internet for anybody to download. By default, on FastAI, when you ask for a model, we will download those weights for you so that you don't start with a random network that can't do anything. You actually start with a network that can do an awful lot. And so then something that FastAI has that's unique is this fine tune method, which what it does is it takes those pre trained weights we downloaded for you and it adjusts them in a really carefully controlled way to just teach the model the differences between your dataset and what it was originally trained for. That's called fine tuning. Hence the name. So that's why you'll see this downloading happen first. And so as you can see, at the end of it, this is the error rate here. After a few seconds, it's 100% accurate. So we now have a learner. And this learner has started with a pre trained model. It's been fine tuned for the purpose of recognizing bird pictures from forest pictures. So you can now call dot predict on it. And dot predict, you pass in an image. And so this is how you would then deploy your model. So in the code you have whatever it needs to do. So in this particular case, this person had some reason that he needs the app to check whether they're in a national park and whether it's a photo of a bird. So at the bit where they need to know if it's a photo of a bird, it would just call this one line of code, learn dot predict. And so that's going to return whether it's a bird or not as a string, whether it's a bird or not as an integer, and the probability that it's a nonbird or a bird. And so that's why we can print these things out. OK. So that's how we can create a computer vision model. What about other kinds of models? There's a lot more in the world than just computer vision. A lot more than just image recognition. Well, even within computer vision, there's a lot more than just image recognition. For example, for example, there's a segmentation. So segmentation, maybe the best way to explain segmentation is to show you the result of this model. Segmentation is where we take photos, in this case of road scenes, and we color in every pixel according to what is it. So in this case, we've got brown as cars, blue as fences, I guess, red as buildings, or brown. And so on the left here, some photos that somebody has already gone through and classified every pixel of every one of these images, according to what that pixel is a pixel of. And then on the right is what our model is guessing. And as you can see, it's getting a lot of the pixels correct, and some of them is getting wrong. It's actually amazing how many is getting correct, because this particular model I trained in about 20 seconds using a tiny, tiny, tiny amount of data. So again, you would think this would be a particularly challenging problem to solve. But it took about 20 seconds of training to solve it not amazingly well, but pretty well. If I had trained it for another two minutes, it'd probably be close to perfect. So this is called segmentation. Now, you'll see that there's very, very little data required, and sorry, very little code required. And the steps are actually going to look quite familiar. In fact, in this case, we're using an even simpler approach. Earlier on, we used data blocks. Data blocks are a intermediate level, very flexible approach that you can take to handling almost any kind of data. But for the kinds of data that occur a lot, you can use these special data loaders classes, which lets you use even less code. So this case to create data loaders for segmentation, you can just say, OK, I'm going to pass you in a function for labeling. And you can see here, it's got pretty similar things that we pass in to what we passed in for data blocks before. So our file names is get image files again. And then our label function is something that grabs this path and the codes. So the labels for segmentation, sorry, the codes. So what does each code mean? It's going to be this text file. But you can see the basic information we're providing is very, very similar, regardless of whether we're doing segmentation or object recognition. And then the next steps are pretty much the same. We create a learner. The segmentation, we create something called a unit learner, which we'll learn about later. And then again, we call fine tune. So that is it. And that's how we create a segmentation model. What about stepping away from computer vision? So perhaps the most widely used kind of model used in industry is tabular analysis. So taking things like spreadsheets and database tables and trying to predict columns of those. So in tabular analysis, it really looks very similar to what we've seen already. We grab some data. And you'll see when I call this untied data, this is the thing in Fast.io that downloads some data and decompresses it for you. And there's a whole lot of URLs provided by Fast.AI for all the kind of common data sets that you might want to use, all the ones that are in the book, or lots of data sets that are kind of widely used in learning and research. So that makes life nice and easy for you. So again, we've got to create data loaders. But this time is tabular data loaders. But we provide pretty similar kind of information to what we have before. A couple of new things. We have to tell it which of the columns are categorical. So they can only take one of a few values and which ones are continuous. So they can take basically any real number. And then again, we can use the exact same show batch that we've seen before to see the data. And so Fast.AI uses a lot of something called typed dispatch, which is a system that's particularly popular in language called Julia, to basically automatically do the right thing for your data regardless of what kind of data it is. So if you call show batch on something, you should get back something useful, regardless of what kind of information you provided. So for a table, it shows you the information in that table. This particular data set is a data set of whether people have less than $50,000 or more than $50,000 in salary for different districts based on demographic information in each district. So to build a model for that data loaders, we do as always something underscore learner. In this case, it's a tabular learner. Now, this time we don't say fine tune. We say fit, specifically fit one cycle. That's because for tabular models, there's not generally going to be a pre trained model that already does something like what you want, because every table of data is very different. Whereas pictures often have a similar theme. You know, they're all pictures. They all have the same kind of general idea of what pictures are. So that's why it generally doesn't make too much sense to fine tune a tabular model. So instead, you just fit. So there is one difference there. I'll show another example. OK. So collaborative filtering. Collaborative filtering is the basis of most recommendation systems today. It's a system where we basically take data that says which users liked which products or which users used which products. And then we use that to guess what other products those users might like based on finding similar users and what those similar users liked. The interesting thing about collaborative filtering is that when we say similar users, we're not referring to similar demographically, but similar in the sense of people who liked the same kinds of products. So for example, if you use any of the music systems, like Spotify or Apple Music or whatever, it'll ask you first what's a few pieces of music you like and you tell it. And then it says, OK, well, maybe let's start playing this music for you. And that's how it works, a user's collaborative filtering. So we can create a collaborative filtering data loaders in exactly the same way that we're used to by downloading and decompressing some data, create our collab data loaders. In this case, we can just say from CSV and passing a CSV. And this is what collaborative filtering data looks like. It's going to have generally speaking a user ID, some kind of product ID. In this case, a movie and a rating. So in this case, this user gave this movie a rating of 3.5 out of 5. And so again, you can see ShowBatch. So use ShowBatch. You should get back some useful visualization of your data regardless of what kind of data it is. And so again, we create a learner. This time it's a collaborative filtering learner. And you pass in your data. In this case, we give it one extra piece of information, which is because this is not predicting a category, but it's predicting a real number, we tell it what's the possible range. The actual range is 1 to 5. But for reasons you'll learn about later, it's a good idea to actually go from a little bit lower than the possible minimum to a little bit higher. So that's why I say 0.5 to 5.5. And then fine tune. Now again, we don't really need to fine tune here because there's not really such a thing as a pre trained collaborative filtering model. We could just say fit or fit one cycle, but actually fine tune works fine as well. So after we train it for a while, this here is the mean squared error. So it's basically about on average how far off are we for the validation set. And you can see as we train, and it's literally so fast, it's less than a second, each epoch. That error goes down and down. And for any kind of fast AI model, you can, and for any kind of fast AI model, you can always call show results and get something sensible. So in this case, it's going to show a few examples of users and movies. Here's the actual rating that user gave that movie. And here's the rating that the model predicted. OK, so apparently a lot of people on the forum are asking how I'm turning this notebook into a presentation. So I'll be delighted to show you because I'm very pleased that these people made this thing for us to use. It's called Rise. And all I do is it's a notebook extension. And in your notebook, it gives you an extra little thing on the side where you say which things are slides or which things are fragments. And a fragment just being, so this is a slide that's a fragment. So if I do that, you see it starts with a slide. And then the fragment gets added in. Yeah, that's about all theories too. Actually, it's pretty great. And it's very well documented. I'll just mention what do I make with Jupyter Notebooks? This entire book was written entirely in Jupyter Notebooks. Here are the notebooks. So if you go to the Fast.io Fastbook repo, you can read the whole book. And because it's all in notebooks, every time we say, here's how you create this plot or here's how you train this model, you can actually create the plot or you can actually train the model because it's all notebooks. The entire Fast.io library is actually written in notebooks. So you might be surprised to discover that if you go to Fast.io slash Fast.io, that the source code for the entire library is notebooks. And so the nice thing about this is that the source code for the Fast.io library has actual pictures of the actual things that we're building, for example. What else have we done with notebooks? Oh, blogging. I love blogging with notebooks because when I want to explain something, I just write the code and you can just see the outputs. And it all just works. Another thing you might be surprised by is all of our tests and continuous integration are also all in notebooks. So every time we change one of our notebooks, every time we change one of our notebooks, hundreds of tests get run automatically in parallel. And if there's any issues, we will find out about it. So yeah, notebooks are great. And RISE is a really nice way to do slides in notebooks. All right. So what can deep learning do at present? We're still scratching the tip of the iceberg, even though it's a pretty well hyped, heavily marketed technology at this point. When we started in 2014 or so, not many people were talking about deep learning. And really, there was no accessible way to get started with it. There were no pre trained models you could download. There was just starting to appear some of the first open source software that would run on GPUs. But yeah, I mean, despite the fact that today there's a lot of people talking about deep learning, we're just scratching the surface. Every time, pretty much somebody says to me, I work in domain X, and I thought I might try deep learning out to see if it can help. And I say them a few months later, and I say, how did it go? They nearly always say, wow, we just broke the state of the art results in our field. So when I say these are things that it's currently state of the art for, these are kind of the ones that people have tried so far. But still, most things haven't been tried. So in NLP, deep learning is the state of the art method in all these kinds of things, and a lot more. Computer vision, medicine, biology, recommendation systems, playing games, robotics. I mean, I've tried elsewhere to make bigger lists, and I just end up with pages and pages and pages. So generally speaking, if it's something that a human can do reasonably quickly, like look at a go board and decide if it looks like a good board or not, even if it needs to be an expert human, then that's probably something that deep learning will be pretty good at. If it's something that takes a lot of logical thought processes over an extended period of time, particularly if it's not based on much data, maybe not. Like who's going to win the next election or something like that? That'd be kind of broadly how I would try to decide is your thing useful for good for deep learning or not. It's been a long time to get to this point. Yes, deep learning is incredibly powerful now, but it's taken decades of work. This was the first neural network. Remember neural networks are the basis of deep learning. So this was back in 1957. The basic ideas have not changed much at all. But we do have things like GPUs now, and solid state drives, and stuff like that. And of course, much more data just is available now. But this has been decades of really hard work by a lot of people to get to this point. So let's kind of take a step back and talk about what's going on in these models. And I'm going to describe the basic idea of machine learning largely as it was described by Arthur Samuel in the late 50s when it was invented. And I'm going to kind of do it with these graphs, which, by the way, you might find fun. These graphs themselves created with Jupyter Notebooks. So these are graph Fizz descriptions that are going to get turned into these. So there's a little sneak peek behind the scenes for you. So let's start with kind of a graph of like, well, what does a normal program look like? So in the pre deep learning and machine learning days, well, you still have inputs, and you still have results. And then you code a program in the middle, which is a bunch of conditionals and loops and setting variables and blah, blah, blah. OK. A machine learning model doesn't look that different. But the program has been replaced with something called a model. And we don't just have inputs now. We now also have weights, which are also called parameters. And the key thing is this. The model is not any more a bunch of conditionals and loops and things. It's a mathematical function. In the case of a neural network, it's a mathematical function that takes the inputs, multiplies them together by the weights, by one set of weights, and adds them up. And then it does that again for a second set of weights and adds them up. It does it again for a third set of weights and adds them up, and so forth. It then takes all the negative numbers and replaces them with zeros. And then it takes those as inputs to a next layer. It does the same thing. It multiplies them a bunch of times and adds them up. And it does that a few times. And that's called a neural network. Now, the model, therefore, is not going to do anything useful. And this leads weights to very carefully, it shows it. And so the way it works is that we actually start out with these weights as being random. So initially, this thing doesn't do anything useful at all. So what we do, the way Arthur Samuel described it back in the late 50s, the inventor of machine learning, is he said, OK, let's take the inputs and the weights, put them through our model. He wasn't talking particularly about neural networks. He's just like, whatever model you like. Get the results. And then let's decide how good they are. So if, for example, we're trying to decide, is this a picture of a bird? And the model said, which initially is random, says this isn't a bird. And actually, it is a bird. We would say, oh, you're wrong. So we then calculate the loss. So the loss is a number that says how good were the results. So that's all pretty straightforward. You know, we could, for example, say, oh, what's the accuracy? We could look at 100 photos and say, which percentage of them did it get right? No worries. Now the critical step is this error. We need as a way of updating the weights that is coming up with a new set of weights that are a bit better than the previous set. And by a bit better, we mean it should make the loss get a little bit better. So we've got this number that says how good is our model? And initially, it's terrible, right? It's random. We need some mechanism if making a little bit better. If we can just do that one thing, then we just need to iterate this a few times. Because each time we put in some more inputs and put in our weights and get our loss and use it to make it a little bit better, then if we make it a little bit better enough times, eventually it's going to get good, assuming that our model is flexible enough to represent the thing we want to do. Now remember what I told you earlier about what a neural network is, which is basically multiplying things together and adding them up and replacing the negatives with zeros. And you do that a few times. That is, provably, an infinitely flexible function. So it actually turns out that that incredibly simple sequence of steps, if you're repeated a few times, you do enough of them, can solve any computable function. And something like generate an artwork based off somebody's Twitter bio is an example of a computable function. Or translate English to Chinese is an example of a computable function. So they're not the kinds of normal functions you do in year eight math, but they are computable functions. And so therefore, if we can just create this step, then and use the neural network as a model, then we're good to go. In theory, we can solve anything given enough time and enough data. And so that's exactly what we do. And so once we've finished that training procedure, we don't need the loss anymore. And even the weights themselves, we can integrate them into the model. We've finished changing them, so we can just say that's now fixed. And so once we've done that, we now have something which puts them through a model and gives us results. It looks exactly like our original idea of a program. And that's why we can do what I described earlier. Once we've got that learned dot predict for our bird recognizer, we can insert it into any piece of computer code. Once we've got a trained model as just another piece of code, we can call with some inputs and get some outputs. Deploying machine learning models in practice can come with a lot of little tricky details. But the basic idea in your code is that you're just going to have a line of code that says learned dot predict. And then you just fit it in with all the rest of your code in the usual way. And this is why, because a trained model is just another thing that maps inputs to results. All right, so as we come to wrap up this first lesson, for those of you that are already familiar with notebooks and Python, this is going to be pretty easy for you. You're just going to be using some stuff that you're already familiar with in some slightly new libraries. For those of you who are not familiar with Python, you're biting into a big thing here. There's obviously a lot you're going to have to learn. And to be clear, I'm not going to be teaching Python in this course. But we do have links to great Python resources in the forum. So check out that thread. Regardless of where you're at, the most important thing is to experiment. And so experimenting could be as simple as just running those cackle notebooks that I've shown you just to see them run. You could try changing things a little bit. I'd really love you to try doing the bird or forest exercise, but come up with something else. Maybe try to use three or four categories, rather than two. Have a think about something that you think would be fun to try. Depending on where you're at, push yourself a little bit, but not too much. So make sure you get something finished before the next lesson. Most importantly, read chapter one of the book. It's got much the same stuff that we've seen today about presented in a slightly different way. And then come back to the forums and present what you've done in the share your work here thread. After the first time we did this in the year one of the course, we got over 1,000 replies. And of those replies, it's amazing how many of them have ended up turning into new startups, scientific papers, job offers. It's been really cool to watch people's journeys. And some of them were just plain fun, you know? So this person classified different types of Trinidad and Tobago people. So people do stuff based on where they live and what their interests are. I don't know if this person is particularly interested in zucchini and cucumber, but they meet as zucchini and cucumber classifier. I thought this was a really interesting one's classifying satellite imagery into what city it's probably a picture of. Amazingly accurate, actually, 85% with 110 classes. Panama City bus classifier, Batic cloth classifier. This one, very practically important, recognizing the state of buildings. We've had quite a few students actually move into disaster resilience based on satellite imagery using exactly this kind of work. We've already actually seen this example, Ethan Sooten, the sound classifier. And I mentioned that with the state of the art, he actually checked up the data sets website in front of the beta state of the art for that. Elena Harley did a German normal sequencing. So she was at Human Longevity International. So she actually did three different, really interesting pieces of cancer work during that first course, if I remember correctly. And I showed you this picture before. What I didn't mention is actually this student club was a software developer at Splunk, big nastak listed company. And this student project, he did, turned into a new patented product at Splunk and a big blog post and the whole thing turned out to be really cool. It's basically something to identify fraudsters using image recognition with these pictures we discussed. One of our students built this startup called InVision. Anyway, there's been lots and lots of examples. So all of this is to say, have a go at starting something, create something you think would be fun or interesting and share it in the forum. If you're a total beginner with Python, then start with something simple. But I think you'll find people very encouraging. And if you've done this a few times before, then try to push yourself a little bit further. And don't forget to look at the quiz questions at the end of the book and see if you can answer them all correctly. All right, thanks everybody so much for coming. OK, thanks so much for coming, everybody. Bye.
