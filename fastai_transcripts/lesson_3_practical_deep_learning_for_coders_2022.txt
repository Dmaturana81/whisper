 Hi everybody and welcome to lesson three of practical deep learning for coders. We did a quick survey this week to see how people feel the course is tracking and over half of you think it's about right pace and of the rest who aren't. Some of you think it's a bit slow and some of you think it's a bit, sorry, some of you think it's a bit fast so hopefully we're at about the best we can do. Generally speaking the first two lessons are a little more easy pacing for anybody who's already familiar with the kind of basic technology pieces and then the later lessons get more into kind of some of the foundations and today we're going to be talking about, you know, things like the matrix modifications and gradients and capitalists and stuff like that. So for those of you who are more mathy and less computery you might find this one more comfortable and vice versa. So remember that there is a official course update thread where you can see all of the up to date info about everything you need to know and of course the course website as well. So by the time you know you watch the video of the lesson it's pretty likely that if you come across a question or an issue somebody else will have so definitely search the forum and check the facts first and then of course feel free to ask a question yourself on the forum if you can't find your answer. One thing I did want to point out which you'll see in the lessons thread and the course website is there is also a lesson zero. lesson zero is based heavily on Radix book meta learning which internally is based heavily on all the things that I've said over the years about how to learn fast. It's we try to make the course full of tidbits about the science of learning itself and put them into the course. It's a different course to probably any other you've taken and it's strongly said recommend watching lessons zero as well. The last bit of lesson zero was about how to set up a Linux box from scratch which you can happily skip over unless that's of interest but the rest of it is full of juicy information that I think you'll find useful. So the basic idea of what to do to do a faster AI lesson is watch the lecture and I generally on the video recommend watching it all the way through without stopping once and then go back and watch it with lots of pauses running the notebook as you go. Because otherwise you're kind of like running the notebook without really knowing where it's heading if that makes sense. And the idea of running the notebook is you could you know there's a few notebooks you could go through so obviously there's the book. So going through chapter one of the book, go through chapter two of the book as notebooks, running every code cell and experimenting with inputs and outputs to try and understand what's going on. And then trying to reproduce those results and then trying to repeat the whole thing with a different data set. And if you can do that last step you know that's quite a stretch goal particularly at the start of the course because there's so many new concepts but that really shows that you've got it sorted. Now first bit reproduce results. I recommend using you'll find in the fast book repo so the repository for the book there is a special folder called plane and plane contains all of the same chapters of the book but with all of the text removed except the headings and all the outputs removed. And this is a great way for you to test your understanding of the chapter is before you run each cell, try to say to yourself okay what's this for and what's it going to output if anything. And if you kind of work through that slowly that's a great way and at any time you're not sure you can jump back to the version of the notebook with the text to remind yourself and then head back over to the clean version. So there's an idea for something which a lot of people find really useful for self study. I say self study but of course as we've mentioned before the best kind of study is study done to some extent with others for most people. You know the research shows that you're more likely to stick with things if you're doing it as kind of a bit of a social activity. The forums are a great place to find and create study groups and you'll also find on the forums a link to our discord server. So our discord server where there are some study groups there as well. So you know in person study groups virtual study groups are a great way to you know really make good progress and find other people at a similar level to you. If there's not a study group going at your level in your area in your time zone, create one. So just post something saying hey let's create a study group. So this week there's been a lot of fantastic activity. I can't show all of it so what I did was I used the summary functionality in the forums to grab all of the things with the highest votes and so I'll just quickly show a few of those. We have a marvel detector created this week. Identify your favorite marvel character. I love this. A rock paper scissors game where you actually use pictures of the rock paper scissors symbols and apparently the computer always loses, that's my favorite kind of game. There is a lot of Elon around so very handy to have an Elon detector to either find more of him if that's what you need or maybe less of him. I thought this one is very interesting. I love these kind of really interesting ideas. It's like gee I wonder if this would work. Can you predict the average temperature of an area based on an aerial photograph? And apparently the answer is yeah actually you can predict it pretty well. Here in Brisbane it was predicted I believe it was in one and a half Celsius. I think this student is actually a genuine meteorologist if I remember correctly. He built a cloud detector. So then building on top of what's your favorite marvel character? There's now a, oh sorry, is it a marvel character? My daughter loves this one. What dinosaur is this? I'm not as good about dinosaurs as I should be. I feel like there's 10 times more dinosaurs than there was when I was a kid. So I never know their name. So this is very handy. This is cool. Choose your own adventure where you choose your path using facial expressions. I think this music genre classification is also really cool. Brian Smith created a Microsoft Power App application that actually runs on a mobile phone. So it's pretty cool. I'm pretty surprised to hear that Brian actually works at Microsoft. So also an opportunity to promote his own stuff there. I thought this art movement classifier was interesting in that there's a really interesting discussion on the forum about what it actually looks like. It actually shows about similarities between different art movements. And I thought this reduction detector project was really cool as well. And there's a whole tweet thread and blog post and everything about this one. Particularly great piece of work. Okay. So I'm going to quickly show you a couple of little tips before we kind of jump into the mechanics of what's behind a neural network. Which is I was playing a little bit with how do you make your neural network more accurate during the week. And so I created this pet detector. And this pet detector is not just protecting dogs or cats, but what breed is it? That's obviously a much more difficult exercise. Now because I put this out on hugging faces, you can download and look at my code because if you just click files and versions on the space, which you can find a link on the forum and the course website, you can see them all here and you can download it to your own computer. So I'll show you what I've got here. Now one thing I mentioned is today I'm using a different platform. So in the past I've shown you coLab and I've shown you Kaggle and we've also looked at doing stuff on your own computer. Not so much training models on your computer, but using the models you've trained to create applications. PaperSpace is another website a bit like Kaggle and Google. But in particular they have a product called Gradient Notebooks, which is at least as I speak and things change all the time, so check the course website. But as I speak, in my opinion is by far the best platform for running this course and for doing experimentation. I'll explain why as we go. So why haven't I been using the past two weeks? Because I've been waiting for them to build some stuff for us to make it particularly good and they just finished. So I've been using it all week and it's totally amazing. This is what it looks like. So you've got a machine running in the cloud. But the thing that was very special about it is it's a real computer you're using. It's not like that kind of weird virtual version of things that Kaggle or CoLab has. So if you whack on this button down here you'll get a full version of Jipit or Lab. Or you can switch over to a full version of plastic Jipit and Notebooks. And I'm actually going to do stuff in Jipit or Lab today because it's a pretty good environment for beginners who are not familiar with the terminal, which I know a lot of people in the course in that situation. You can do really everything kind of graphically. There's a file browser. So here you can see I've got my pets repo. I've got a git repository thing you can pull and push to git. And then you can also open up a terminal, create new Notebooks and so forth. So what I tend to do with this is I tend to go into a full screen. It's kind of like its own whole IDE. And so you can see I've got here my terminal. Here's my notebook. They have free GPUs. And most importantly there's two good features. One is that you can pay, I think it's $8 or $9 a month to get better GPUs. And basically as many hours as you want. And they have persistent storage. So with CoLab, if you've played with it you might have noticed it's annoying. You have to map around with saving things to Google Drive and stuff. Some cackle that isn't really a way of having a persistent environment. Where else on paper space you have, whatever you save in your storage it's going to be there the next time you come back. So I'm going to be adding walk throughs of all of this functionality. So if you're interested in really taking advantage of this, check those out. Okay, so I think the main thing that I wanted you to take away from lesson two isn't necessarily all the details of how do you use a particular platform to train models and deploy them into applications through JavaScript or online platforms. But the key thing I wanted you to understand was the concept. There's really two pieces. There's the training piece and at the end of the training piece you end up with this model.pickle file. And once you've got that, that's now a thing where you feed it inputs and it spits out outputs based on that model that you trained. And then so you don't need, you know, because that happens pretty fast you generally don't need a GPU once you've got that trained. And so then there's a separate step which is deploying. So I'll show you how I trained my pet classifier. So you can see I've got two IPython notebooks. One is app which is the one that's going to be doing the inference and production. One is the one where I train the model. So this first bit I'm going to skip over because you've seen it before. I create my image data loaders, check that my data looks okay with show batch, train to resident 34 and I get 7% accuracy. So that's pretty good. But check this out. There's a link here to a notebook I created. Actually most of the work was done by Ross Whiteman where we can try to improve this by finding a better architecture. Here I think at the moment in the PyTorch image models libraries over 500 architectures and we'll be learning over the course what they are, how they differ. But you know, broadly speaking they're all mathematical functions, you know, which are basically matrix modifications and these nonlinearities such as values that we're talking about today. So most of the time those details don't matter, what we care about is three things. How fast are they? How much memory do they use and how accurate are they? And so what I've done here with Ross is we've grabbed all of the models from PyTorch image models and you can see all the code we've got is very, very little code to create this plot. Now my screen resolution is a bit, there we go, let's do that. And so on this plot on the next axis we've got seconds per sample, so how fast is it? So the left is better, it's faster. And on the right is how accurate is it? So how accurate was it on ImageNet in particular? And so generally speaking you want things that are up towards the top and left. Now we've been mainly working with ResNet and you can see down here here's ResNet 18. Now ResNet 18 is a particularly small and fast version for prototyping, we often use ResNet 34, which is this one here. And you can see this kind of like classic model that's very widely used, actually nowadays isn't the state of the art anymore. So we can start to look up at these ones up here and find out some of these better models. The ones that seem to be the most accurate and fast for these levered models, so I tried them out on my pets and I found that they didn't work particularly well, so I thought okay let's try something else out. So next up I tried these ComfNext models and this one in here was particularly interesting, it's kind of like super high accuracy, it's the, you know, if you watch 0.001 seconds inference time it's the most accurate. So I tried that, so how do we try that? What we do is I can say, so the PyTorch image models is in the TIM module, so the very start I imported that and we can say list models and pass in a glob, a match, and so this is going to show all the ComfNext models and here I can find the ones that I just saw and all I need to do is when I create the vision learner I just put the name of the model in as a string, okay. So you'll see earlier this one is not a string, that's because it's a model that FastAI provides, the library, FastAI only provides a pretty small number, so if you install Tim, so you need to pip install Tim or condor install Tim, you'll get hundreds more and you put that in a string. So if I now train that, the time for these epochs goes from 20 seconds to 27 seconds, so it is a little bit slower, but the accuracy goes from 7.2% down to 5.5%. So that's a pretty big relative difference, 7.2 divided by 5.5, yeah, so about a 30% improvement. So that's pretty fantastic and it's been a few years, honestly, since we've seen anything really big ResNet that's widely available and usable on regular GPUs, so this is a big step and so this is a, you know, there's a few architectures nowadays that really are probably better choices a lot of the time and these cons, so if you are not sure what to use, try these cons next architectures, you might wonder what the names are about, obviously, Chinese, more large, etc. is how big is the model, so that'll be how much memory is it going to take up and how fast is it. And then these ones here that say N22FT1K, these ones have been trained on more data. So ImageNet, there's two different ImageNet data sets, there's one that's got 1000 categories of pictures and there's another one that's got 22,000 categories of pictures. So this is trained on the one with 22,000 categories of pictures. So these are generally going to be more accurate on kind of standard photos of natural objects. Okay, so from there I exported my model and that's the end. Okay, so now I've trained my model and I'm all done. You know, other things you can do, obviously, is add more epochs, for example, add image augmentation, there's various things you can do, but you know, I've found this is actually pretty hard to beat this by much. If any of you find you can do better, I'd love to hear about it. So then I'll turn that into an application. I just did the same thing that we saw last week, which was to load the learner. As is something I did want to show you, the learner, once we load it and call predict, spits out a list of 37 numbers. That's because there are 37 breeds of dark and cat. So these are the probability of each of those breeds. What order they are they in? That's an important question. The answer is that FastAI always stores this information about categories. This is a category in this case of double or cat breed in something called the vocab object and it's inside the data lovers. So we can grab those categories and that's just a list of strings. Just tells us the order. So if we now zip together the categories and the probabilities, we'll get back a dictionary that tells you, well, like so. So here's that list of categories and here's the probability of each one. And this was a Basset Hound so that you can see on the certainly Basset Hound. So from there, just like last week, we can go and create our interface and then launch it. And there we go. Okay. So what did we just do really? What is this magic model.pickle file? So we can take a look at the model.pickle file. It's an object type called a learner and a learner has two main things in it. The first is the list of preprocessing steps that you did to turn your images into things of the model and that's basically this information here. So it's your data blocks or your image data loaders or whatever. And then the second thing, most importantly, is the trained model. And so you can actually grab the trained model by just grabbing the dot model attribute. So I'm just going to call that m and then if I type m, I can look at the model. And so here it is, lots of stuff. So what is this stuff? Well, we'll learn about it all over time. But basically what you'll find is it contains lots of layers because this is a deep learning model. And you can see it's kind of like a tree. That's because lots of the layers themselves consist of layers. So there's a whole layer called the Kim body, which is most of it. And then right at the end, there's a second layer called sequential. And then the Tim body contains something called model. And it contains something called stem and something called stages. And then stages contain zero, one, two, et cetera. So what is all this stuff? Well, let's take a look at one of them. So to take a look at one of them, there's a really convenient method in PyTorch called getSubModule where we can pass in a dotted string navigating through this hierarchy. So zero model stem one goes zero model stem one. So this is going to return this layer non 2D thing. So what is this layer non 2D thing? Well, the key thing is it's got some code with the mathematical function that we talked about. And the other thing that we learned about is it has parameters. So we can list this parameters and look at this. It's just lots and lots and lots of numbers. Let's grab another example. We could have a look at zero dot model dot stages dot zero dot blocks dot one dot MLP dot F C one and parameters and other big bunch of numbers. So what's going on here? What are these numbers and where it is that they come from and how come these numbers can figure out whether something is a basset hound or not? Okay. So to answer that question, we're going to have a look at a Kaggle notebook. How does a neural network really work? I've got a local version of it here, which I'm going to take you through. And the basic idea is machine learning models are things that fit functions to data. So we start out with a very, very flexible, in fact, an infinitely flexible as we discussed function, a neural network. And we get it to do a particular thing, which is to recognize the patterns in the data examples we give it. So let's do a much simpler example than a neural network. Let's do a quadratic. So let's create a function F, which is 3x squared plus 2x plus 1. Okay. So it's a quadratic with coefficient 3, 2, and 1. So we can plot that function F and give it a title. If you haven't seen this before, things between dollar signs is what's called LaTeX. It's basically how we can create kind of typeset mathematical equations. Okay. So let's run that. And so here you can see the function. Here you can see the title I passed it. And here is our quadratic. Okay. So what we're going to do is we're going to imagine that we don't know that's the true mathematical function we're trying to find. It's obviously much simpler than the function that figures out whether an image is a Basset Hound or not, that we're just going to start super simple. So this is the real function and we're going to try to recreate it from some data. Now it's going to be very helpful if we have an easier way of creating different quadratics. So I have to find a kind of a general form of a quadratic here with coefficients a, b, and c. And at some particular point x is going to be ax squared plus bx plus c. And so let's test that. Okay, so that's for x equals 1.5. That's 3x squared plus 2x plus 1, which is the quadratic we were getting before. Now we're going to want to create lots of different quadratics to test them out and find which one's best. So this is a somewhat advanced but very, very helpful feature of Python that's worth learning if you're not familiar with it. And it's used in a lot of programming languages. It's called a partial application of a function. Basically I want this exact function, but I want to fix the values of a, b, and c to pick a particular quadratic. And the way you fix the values of the function is you call this thing in Python called partial and you pass in the function and then you pass in the values that you want to fix. So for example, if I now say make a quadratic 3, 2, 1, that's going to create a quadratic equation with coefficients 3, 2, and 1. And you can see if I then pass in, so that's now f. If I pass in 1.5, I get the exact same value I did before. Okay, so we've now got an ability to create any quadratic equation we want by passing in the parameters of the, the coefficients of the quadratic. And that gives us a function that we can then just call as just like any normal function. So that only needs one thing now, which is a value of x, because the other three, a, b, and c, are now fixed. So if we plot that function, we'll get exactly the same shape, because it's the same coefficients. Okay, so now I'm going to show an example of, of some data, some data that matches the shape of this function. But in real life, data is never exactly going to match the shape of a function. It's going to have some noise. So here's a couple of functions to add some noise. So you can see, I've still got the basic functional form here, but this data is a bit dotted around it. The level to which you look at how I implemented these is entirely up to you. It's not like super necessary, but it's all stuff which, you know, the kind of things we use quite a lot. So this is to create normally distributed random numbers. This is how we set the seed. So that each time I run this, I've got to get the same random numbers. This one is actually particularly helpful. This creates a, a tensor. So in this case, a vector that goes from negative to, to two in equal steps, and there's 20 of them. And there's 20 steps along here. So then my y values is just f of x with this amount of noise added. Okay. So as I say, the details of that don't matter too much. The main thing to know is we've got some random data now. And so this is, the idea is now we're going to try to reconstruct the original quadratic equation, find one which matches this data. So how would we do that? Well, what we can do is we can create a function called quadratic that first of all plots our data as a scatter plot, and then it plots a function which is a quadratic, a quadratic we pass in. Now, there's a very helpful thing for experimenting in Jupiter notebooks, which is the at interact function. So if you add it on top of a function, then it gives you these nice little sliders. So here's an example of a quadratic with coefficients 1.5, 1.5, 1.5. And it doesn't fit particularly well. So how would we try to make this fit better? Well, I think what I'd do is I'd take the first slider, and I would try moving it to the left and see if it looks better or worse. It looks worse to me. I think it needs to be more curvy. So try the other way. Yeah, that doesn't look bad. Let's do the same thing for the next slider. Have it this way. No, I think that's worse. Let's try the other way. Okay, final slider. Try this way. No, it's worse this way. So you can see what we can do. We can basically pick each of the coefficients. One at a time, try increasing a little bit, see if that improves it, try decreasing it a little bit, see if that improves it, find the direction that improves it, and then slide it in that direction a little bit. And then when we're done, we can go back to the first one and see if we can make it any better. Now we've done that. And actually, you can see that's not bad because I know the answer's meant to be 321. So they're pretty close. And I wasn't shooting, I promise. That's basically what we're going to do. That's basically how those parameters are created. But we obviously don't have time because the big fancy models have often hundreds of millions of parameters. We don't have time to try 100 million sliders. So we did something better. Well, the first step is we need a better idea of like, when I move it, is it getting better or is it getting worse? So if you remember back to Arthur Samuel's description of machine learning that we learned about chapter one of the book and in lesson one, we need something we can measure, which is a number that tells us how good is our model. And if we had that, then as we move these sliders, we could check to see whether it's getting better or worse. So this is called a loss function. So there's lots of different loss functions you can pick. But perhaps the most simple and common is mean squared error, which is going to be, so it's going to get our predictions and it's got the actuals and we're going to go predictions minus actuals squared and take the mean. So that's mean squared error. So if I now rerun the exact same thing I had before, but this time I'm going to calculate the loss, the MSC between the values that we predict, f of x, remember where f is the quadratic we created and the actuals, why? And this time I'm going to add a title to our function, which is the loss. So now let's do this more rigorously. We're starting at a mean squared error of 11.46. So let's try moving this to the left and see if it gets better. No, what? So we're moving to the right. All right, so we're around there. Okay, now let's try this one. Okay, best when I go to the right. Okay, what about C? 3.91, it's getting worse. So I keep going. Sorry about that. And so now we can repeat that process, right? So we've added, A, B and C move a little bit. Let's go back to A. Can I get any better than 3.28? Let's try moving left. Yeah, left was a bit better. And for B, let's try moving left. Worse, right was better. And to finally see, move to the right. Oh, definitely better. There we go. Okay, so that's a more rigorous approach. It's still manual, but at least we can like, we don't have to rely on us to kind of recognize which is a little better or a little worse. So finally, we're going to automate this. So the key thing we need to know is for each parameter, when we move it up, does the loss get better? Or when we move it down, does the loss get better? Another approach would be to try it, right? We could manually increase the parameter a bit and see if the loss improves and vice versa. But there's a much faster way. And the much faster way is to calculate its derivative. So if you've forgotten what a derivative is, no problem. There's lots of tutorials out there. You could go to Khan Academy or something like that. But in short, the derivative is what I just said. The derivative is a function that tells you if you increase the input, does the output increase or decrease? And by how much? So that's called the slope or the gradient. Now, the good news is PyTorch can automatically calculate that for you. So if you went through horrifying months of learning derivative rules in year 11 and you're worried you're going to have to remember them all again, don't worry, you don't. You don't have to calculate any of this yourself. It's all done for you. Watch this. So the first thing to do is we need a function that takes the coefficients of the quadratic A, B, and C as inputs. I've got to put them all on the list. You'll see why in a moment. I kind of call them parameters. We create a quadratic passing in those parameters A, B, and C. This star on the front is a very, very common thing in Python. Basically, it takes these parameters and spreads them out to turn them into A, B, and C and pass each of them to the function. So we've now got a quadratic with those coefficients. And then we return the means of red error of our predictions against our actions. So this is a function that's going to take the coefficients of a quadratic and return the loss. So let's try it. Okay. So if we start with A, B, and C of 1.5, we get a mean squared error of 11.46. It looks a bit weird. It says it's a tensor. So don't worry about that too much. In short, in PyTorch, everything is a tensor. A tensor just means that it doesn't just work with numbers. It also works with lists or vectors of numbers. It's got a 1D tensor, rectangles of numbers, so tables of numbers. It's got a 2D tensor, layers of tables of numbers, that's got a 3D tensor, and so forth. So in this case, this is a single number, but it's still a tensor. That means it's just wrapped up in the PyTorch machinery that allows it to do things like calculate derivatives. But it's still just the number of 11.46. All right, so what I'm going to do is I'm going to create my parameters, A, B, and C. I'm not going to put them all in a single 1D tensor. Now, 1D tensor is also known as a rank 1 tensor. So this is a rank 1 tensor. And it contains a list of numbers, 1.5, 1.5, 1.5. And then I've got a tail PyTorch that I want you to calculate the gradient for these numbers whenever we use them in a calculation. And the way we do that is we just say requires credit. So here is our tensor. It contains 1.5 three times. And it also tells us it's, we flagged it to say, please calculate gradients for this particular tensor when we use it in calculations. So let's now use it in the calculation. We're going to pass it to that quad MSC. That's the function we just created that gets the MSC, the mean spread error for a set of coefficients. And not surprisingly, it's the same number we saw before, 11.46. Okay. Not very exciting, but there is one thing that's very exciting. It is an extra thing to the end called grad function. And this is the thing that tells us that if we wanted to, PyTorch knows how to create a calculator, calculate the gradients for our inputs. And to tell PyTorch, just please go ahead and do that calculation. You'll call backward on the result of your loss function. Now when I run it, nothing happens or it doesn't look like nothing happens. But what does happen is it's just added an attribute called grad, which is the gradient to our inputs ABC. So if I run this cell, this tells me that if I increase A, the loss will go down. If I increase B, the loss will go down a bit less. And if I increase C, the loss will go down. Now we want the loss to go down. Right? So that means we should increase A, B and C. Well how much by? Well given that A says if you increase A even a little bit, the loss improves a lot. That suggests we're a long way away from the right answer. So we should probably increase this one a lot, this one the second most, and this one the third most. So this is saying when I increase this parameter, the loss decreases. So in other words, we want to adjust our parameters A, B and C by the negative of these. We want to increase, increase, increase. So we can do that by saying, okay, let's take our ABC minus equals, so that means equals ABC minus the gradient. But we're just going to like decrease it a bit. We don't want to jump too far. So just we're just going to go a small distance. So we're just going to somewhat arbitrarily pick point 01. So that is now going to create a new set of parameters, which are going to be a little bit bigger than before because we subtracted negative numbers. And we can now calculate the loss again. So remember before it was 11.46, so hopefully it's going to get better. Yes it did, 10.11. There's one extra line of code which we didn't mention, which is with torch.nograd. Remember earlier on we said that the parameter ABC requires grad and that means PyTorch will automatically calculate its derivative when it's used in a function. Here it's being used in a function, but we don't want the derivative of this. This is not our loss. This is us updating the gradients. So this is basically the standard inner part of a PyTorch loop and every neural net, deep in pretty much every machine running model at least of this style that your build basically looks like this. If you look deep inside faster source code, you'll see something that basically looks like this. So we could automate that, right? So let's just take those steps, which is we're going to calculate, let's go back to here, we're going to calculate the mean squared error for our quadratic, call backward and then subtract the gradient times a small number from the gradient. So let's do it five times. So far we're up to a loss of 10.1, so we're going to calculate our loss, call dot backward to calculate the gradients and then with no grad, subtract the gradients times a small number and print how we're going. And there we go, the loss keeps improving. So we now have some coefficients and there they are, 3.2, 1.9, 2.0. So they're definitely heading in the right direction. So that's basically how we do, it's called optimization. Okay, so you'll hear a lot in deep learning about optimizers. This is the most basic kind of optimizer, but they're all built on this principle with called gradient descent. And you can see why it's called gradient descent. We calculate the gradients and then do a descent which is in, we're trying to decrease the loss. So believe it or not, that's the entire foundations of how we create those parameters. So we need one more piece, which is what is the mathematical function that we're finding parameters for? We can't just use quadratics, right? Because it's pretty unlikely that the relationship between parameters and whether a pixel is part of a basset hound is quadratic. It's going to be something much more complicated. No problem. It turns out that we can create an infinitely flexible function from this one tiny thing. This is called a rectified linear unit. The first piece I'm sure you will recognize, it's a linear function. We've got our output y, our input x and coefficients m and b. This is even simpler than our quadratic. And this is a line. And torch dot flip is a function that takes our output y and if it's greater than that number, it turns it into that number. In other words, this is going to take anything that's negative and make it zero. So this function is going to do two things. Calculate the output of a line and if it is bigger than a smaller than zero, it'll make it zero. So that's rectified linear. So let's use partial to take that function and set the m and b to one and one. So this is now going to be this function here where it will be y equals x plus one followed by this torch dot flip. And here's the shape. As you would expect, it's a line until it gets under zero when it becomes a horizontal line. So we can now do the same thing. We can take this plot function and make it interactive using interact. And we can see what happens when we change this two parameters, m and b. So we're now plotting the rectified linear and fixing m and b. So m is the slope. And b is the intercept with a shift up and down. Okay, so that's how those work. Now why is this interesting? Well it's not interesting of itself. But what we could do is we could take this rectified linear function and create a double value which adds up two rectified linear functions together. So there's some slope m one b one, some slope n two b two. So we can calculate it at some point x. And so let's take a look at what that function looks like if we plot it. And you can see what happens is we get this downward slope and then a hook and then an upward slope. So if I change m one, it's going to change the slope of that first bit. And b one's going to change its position. Okay. And I'm sure you won't be surprised to hear that m two changes the slope of the second bit and b two changes that location. Now this is interesting. Why? Because we don't just have to do a double value. We could add as many values together as we want. And if we add as many values together as we want, then we can have an arbitrarily squiggly function and with enough values, we can match it as close as we want. Right? So you could imagine incredibly squiggly, like, I don't know, like an audio waveform of me speaking. And if I gave you a hundred million values to add together, you could almost exactly match that. Now we want functions that are not just that we've plotted in two D. We want things that can have more than one input. But you can add these together across as many dimensions as you like. And so exactly the same thing will give you a a a value over surfaces or a value over 3D, 4D, 5D and so forth. And it's the same idea. With this incredibly simple foundation, you can construct an arbitrarily accurate precise model. Problem is, you need some numbers for them. You need parameters. Oh, no problem. We know how to get parameters. We use gradient descent. So believe it or not, we have just derived take money. From now on is tweaks to make it faster and make it need less data. You know, this is it. Now I remember a few years ago when I said something like this in a class, somebody on the forum was like, this reminds me of that thing about how to draw an L. Jeremy is basically saying, okay, step one, draw two circles, step two, draw the rest of the L. The thing I find I have a lot of trouble explaining to students is when it comes to deep learning, there's nothing between these two steps. When you have, where do you use getting added together? And gradient descent to optimize the parameters. And samples of inputs and outputs that you want. The computer draws the L. Right? That's it. So we're going to learn about all these other tweaks and they're all very important. But when you come down to like try and understand something in deep learning, just try to keep coming back to remind yourself of what it's doing, which it's using gradient descent to set some parameters to make a wiggly function, which is basically the addition of lots of rectified linear units or something very similar to that. That's your data. Okay. So we've got some questions on the forum. Okay. So question from Zuck here with six upvotes. So for those of you watching the video, what we do in the lesson is we want to make sure that the questions that you hear answered are the ones that people really care about. So we pick the ones which get the most upvotes. The question is, is there perhaps a way to try out all the different models and automatically find the best performing one? Yes, absolutely you can do that. So if we go back to our training script, remember there's this thing called list models and it's a list of strings. So you could easily add a for loop around this that basically goes for architecture in chim.list models and you could do the whole lot, which would be like that. And then you could do that and away you go. It's going to take a long time for 500 and something models. So generally speaking, I've never done anything like that myself. I would rather look at a picture like this and say, okay, where am I in? The vast majority of the time, this is something, this would be the biggest, I reckon, number one mistake of beginners I see, is that they jump to these models from the start of a new project. At the start of a new project, I pretty much only use Resident 18 because I want to spend all of my time trying things out and try different data augmentation. I'm going to try different ways of cleaning the data. I'm going to try, you know, different external data I can bring in. So I want to be trying lots of things and I want to be able to try it as fast as possible. So trying better architectures is the very last thing that I do. And what I do is once I've spent all this time and I've got to the point where I've got, okay, I've got my Resident 18 or maybe, you know, Resident 34 because it's nearly as fast. And I'm like, okay, well, how accurate is it? How fast is it? Do I need it more accurate for what I'm doing? Do I need it faster for what I'm doing? Could I accept some trade off to make it a bit slower, to make it more accurate? And so then I'll have a look and I'll say, okay, well, I kind of need to be somewhere around.001 seconds and so I'll try a few of these. So that'd be how I would think about that. Okay, next question from the forum is around, how do I know if I have enough data? What are some signs that indicate my problem needs more data? I think it's pretty similar to the architecture question. So you've got some amount of data. Presumably, you've started using all the data that you have access to. You've built your model, you've done your best. Is it good enough? Do you have the accuracy that you need for whatever it is you're doing? You can't know until you've trained the model, but as you've seen, it only takes a few minutes to train a quick model. So my very strong opinion is that the vast majority of projects I see in industry wait far too long before they train their first model. In my opinion, you want to train your first model one day one with whatever CSV files or whatever that you can hack together. And you might be surprised that none of the fancy stuff you're thinking of doing is necessary because you already have a good enough accuracy for what you need. Or you might find quite the opposite. You might find that, oh my God, we're basically getting no accuracy at all. Maybe it's impossible. These are things you want to know at the start, not at the end. We'll learn lots of techniques, both in this part of the course and in part two, about ways to really get the most out of your data. In particular, there's a reasonably recent technique called semi supervised learning, which actually lets you get dramatically more out of your data. And we've also started talking already about data augmentation, which is a classic technique you can use. So generally speaking, it depends how expensive it's going to be to get more data. But also, what do you mean when you say get more data? Do you mean more labeled data? Often, it's easy to get lots of inputs and hard to get lots of outputs. For example, in medical imaging, where I spent a lot of time, it's generally super easy to jump into the radiology archive and grab more CT scans. But it might be very difficult and expensive to draw segmentation masks and pixel boundaries and so forth on them. So often, you can get more, in this case, images or texts or whatever, and maybe it's harder to get labels. And again, there's a lot of stuff you can do using things like we'll discuss semi supervised learning to actually take advantage of unlabeled data as well. Okay. Final question here. In the quadratic example, where we calculated the initial derivatives for A, B, and C, we got values of minus 10.8, minus 2.4, et cetera. What unit are these expressed in? Why don't we adjust our parameters by these values themselves? So I guess the question here is why are we multiplying it by a small number, which in this case is 0.01. Okay, let's take those two parts of the question. What's the unit here? The unit is, for each increase in X of 1, how much does, sorry, for each increase in A of 1, so if I increase A from, in this case, we have 1.5. So if we increase from 1.5 to 2.5, what would happen to the loss? And the answer is it would go down by 10.98. Now that's not exactly right because it's kind of like, it's kind of like in an infinitely small space, right, because actually it's going to be curved, right? But if it stays at that slope, that's what would happen. So if we increased B by 1, the loss would decrease if it stayed constant, you don't see if the slopes stayed the same, the loss would decrease by minus 2.1 to 2. Okay, so why would we not just change it directly by these numbers? So the reason is that if we have some function that we're fitting. And there's some kind of interesting theory that says that once you get close enough to the optimal value, all functions look like quadratic anyway. So we can kind of safely draw it in this kind of shape because this is what they end up looking like if you get close enough. And we're, like, let's say we're way out over here. Okay, so we were measuring, I used my daughter's favorite pens and I sparkly ones, so we're measuring the slope here. There's a very steep slope, okay? So that seems to suggest we should jump a really long way. So we jump a really long way. And what happened? Well, we jumped way too far. And the reason is that that slope decreased as we moved along. And so that's generally what's going to happen, right? Particularly as you approach the optimal, is generally the slope's going to decrease. So that's why we multiply the gradient by a small number. And that's more number, it's a very, very, very important number. It has a special name. It's called the learning rate. And this is an example of a hyperparameter. It's not a parameter. It's not one of the actual coefficients of your function. That's a parameter you use to calculate the parameters. Pretty better, right? It's a hyperparameter. And so it's something you have to pick. Now we haven't picked any yet in any of the stuff we've done, did I remember? And that's because Basteri generally picks reasonable defaults for most things. But later in the course, we will learn about how to try and find really good learning rates. And you will find sometimes you need to actually spend some time finding a good learning rate. You could probably understand the intuition here. If you pick a learning rate that's too big, you'll jump too far. And so you'll end up way over here. And then you will try to then jump back again and you'll jump too far the other way and you'll actually diverge. And so if you ever see when your model's trading, it's getting worse and worse, probably means your learning rate's too big. What would happen on the other hand if you pick a learning rate that's too small, then you're going to take tiny steps. And of course the flatter it gets, the smaller the steps are going to get. And so you're going to get very, very bored. So finding the right learning rate is a compromise between the speed at which you find the answer and the possibility that you're actually going to shoot past it and get worse and worse. Okay, so one of the bits of feedback I got quite a lot in the survey is that people want a break halfway through, which I think is a good idea. So I think now is a good time to have a break. So let's come back in 10 minutes at 25 past 7. Okay, I hope you had a good rest. Have a good break, I should say. So I want to now show you a really, really important mathematical computational trick, which is we want to do a whole bunch of values. All right, so we're going to be wanting to do a whole lot of mx plus b's. And we want to just want to do mx plus b. We're going to want to have like lots of variables. So for example, every single pixel of an image would be a separate variable. So we're going to multiply every single one of those times some coefficient and then add them all together and then do the crop, the value, and then we're going to do it a second time with a second bunch of parameters and then a third time and a fourth time and a fifth time. It's going to be pretty inconvenient to write out 100 million values. But so happens there's a mathematical, single mathematical operation that does all of those things for us except for the final replace negatives with zeros. That's called matrix modification. I expect everybody at some point did matrix modification at high school. I suspect also a lot of you have forgotten how it works. When people talk about linear algebra in deep learning, they give the impression you need years of graduate school study to learn all this linear algebra. You don't. Actually, all you need almost all the time is matrix multiplication and it couldn't be simpler. First is a really cool site called matrix modification.xyz. You can put in any matrix you want. I'm going to put in this one. This matrix is saying I've got three rows of data with three variables. Maybe they're tiny images with three pixels and the value of the first one is one, two, one, and the second is 011 and the third is 231. Those are our three rows of data. These are our three sets of coefficients. We've got A, B and C in our data. So I guess we'd call it X1, X2 and X3. Then here's our first set of coefficients, A, B and C, two, six and one. Our second set is five, seven and eight. Here's what happens when we do matrix multiplication. That second, this matrix here of coefficients gets flipped around and we do, this is the multiplications and additions that I mentioned. So multiply, add, multiply, add, multiply, add. That's going to give you the first number because that is the left hand column of the second matrix times the first row. That gives you the top left result. So the next one is going to give us two results. So we've got now the right hand one with the top row and the left hand one with the second row. Keep going down, keep going down and that's it. That's what matrix multiplication is. It's modifying things together and adding them up. So there'd be one more step to do to make this a layer of a neural network which is if this had any negatives, we'd place them with yours. That's why matrix multiplication is the critical foundation or mathematical operation in basically all of deep learning. So the GPUs that we use, the thing that they are good at is this, matrix multiplication. They have special cores called tensor cores which can basically only do one thing which is to multiply together two 4 by 4 matrices and then they do that lots of times, so bigger matrices. So I'm going to show you an example of this. We're actually going to build a complete machine learning model on real data in the spreadsheet. So fast AI has become kind of famous for a number of things and one of them is using spreadsheets to create deep learning models. We haven't done it for a couple of years so I'm pretty pumped to show this to you. What I've done is I went over to Kaggle where there's a competition actually helped create many years ago called Titanic. And it's like an ongoing competition. So 14,000 people have entered it so, well teams have entered it so far. It's just a competition for a bit of fun. There's no end date. And the data for it is the data about who survived and who didn't from the real Titanic disaster. And so I clicked here on the down my button to grab it on my computer. That gave me a CSV which I opened up in Excel. The first thing I did then was I just removed a few columns that clearly were not going to be important. Things like the name of the passengers, the passenger ID, just to try to make it a bit simpler. And so I've ended up with each row of this is one passenger. First column is the dependent variable, the dependent variable is the thing we're trying to predict. Did they survive? And the remaining are some information such as what class of the boat, first, second, or third class, this, X, the age, how many siblings in the family? Pee arch, I think is parents or something? So you should always look for a data dictionary to find out what's what? A number of parents and children. What was their fare? And which of the three cities did they embark on? Jerpa, Queenstown, South Africa. Okay. So there's that data. Now when I first grabbed it, I noticed that there were some people with no age. Now there's all kinds of things we could do for that. Now for this purpose, I just decided to remove them. And I found the same thing for embarked. I removed the blanks as well. But that left me with nearly all of the data. Okay. So then I've put that over here. Here's our data with those rows removed. And okay, that's the, so these are the columns that came directly from Kaggle. So basically what we now want to do is we want to multiply each of these by coefficient. How do you multiply the word male by coefficient? And how do you multiply S? coefficient? You can't. So I converted all of these to numbers. Male and female are very easy. I created a column called Is Male. And as you can see, there's just an if statement that says if sex is male, that's one. Otherwise it's zero. And we can do something very similar for embarked. We can have one column called did they embark in Southampton? Same deal. And another column for did they, what's it called? Cherpa. Did they embark in Cherpa? And their peak loss is one, two or three, which is a number. But it's not really a continuous measurement of something. There isn't one or two or three things. They're different levels. So I decided to turn those into similar things into these binary. These are called binary categorical variables. So are they first class and are they second class? Okay. So that's all that. The other thing that I was thinking, well, you know, then I kind of tried it and checked out what happened. And what happened was the people with, so I created some random numbers. So to create the random numbers, I just went equals rand, right? And I copied those to the right. And then I just went copy and I went paste values. So that gave me some random numbers. And that's my like, so just because like I said, before I said, oh, A, B and C, let's just start them at 1.5, 1.5, 1.5. What we do in real life is we start our parameters at random numbers that are a bit more or a bit less than zero. So these are random numbers. Actually, sorry, I slightly lied. I didn't use rand. I used rand minus 0.5. And that way I've got small numbers that were on either side of zero. So then when I took each of these and I multiplied them by our fairs and ages and so forth, what happened was that these numbers here are way bigger than these numbers here. And so in the end, all that mattered was what was their fair? Because they were bigger than everything else. So I wanted everything to basically go from zero to one. These numbers were too big. So what I did up here is I just grabbed the maximum of this column, the maximum of all the fairs is 512. And so then actually I do age first. I did maximum of age because similar thing, right? There's 80 year olds and there's two year olds. And so then over here I just did, okay, well what's their age divided by the maximum? And so that way all of these have a 20 year old one, just like all of these have a 20 year old one. So that's how I fix this is called normalizing the data. Now we haven't done any of these things when we've done stuff with FastAI. That's because FastAI does all of these things for you. And we'll learn about how, right? And all these things are being done behind the scenes. For fair, I did something a bit more, which is I noticed there's lots of very small fairs and there's also some, a few very big fairs, so like $70 and then $7, $7. Generally speaking when you have lots of really big numbers and a few small ones. So generally speaking when you've got a few really big numbers and lots of really small numbers. And it's very common with money, you know, because money kind of follows this relationship where a few people have lots of it and there's been huge amounts of it and most people don't have heaps. If you take the log of something that's like, that has that kind of extreme distribution, you end up with something that's much more evenly distributed. So I've added this here called log fair, as you can see. And these are all around one which isn't bad. I could have normalized that as well, but I was too lazy I didn't bother because it seemed okay. So at this point you can now see that if we start from here, all of these are all around the same kind of level, right? So none of these columns are going to saturate the others. So now I've got my coefficients, which is, as I said, they're just random. And so now I need to basically calculate AX1 plus BX2 plus CX3 plus blah, blah, blah, blah, blah, blah. Okay. And so to do that, you can use some product in Excel. I could have typed it out by hand. It could be very boring, but some product is just going to multiply each of these. This one will be multiplied by, there is it. And set by this one, this one will be multiplied by this one, so forth, and then they get all added together. Now one thing, if you're eagle eyed, you might be wondering, is in a linear equation, we have y equals MX plus B. At the end, there's this constant term. And I do not have any constant term. I've got something here called const, but I don't have any plus at the end. How's that working? Well, there's a nice trick that we pretty much always use in machine learning. We're just to add a column of data, just containing the number one every time. If you have a column of data containing the number one every time, then that parameter becomes your constant term. So you don't have to have a special constant term, and so it makes out. It's a little bit simpler. We need to do it that way. It's just a trick, but everybody does it. Okay, so this is now the result of our linear model. So this is not even going to do value. I'm just going to do the plane regression. Now if you've done regression before, you might have learned about it as something you kind of solve with various matrix things. But in fact, you can solve a regression using gradient descent. So I've just kind of had a loss for each row, and so the loss is going to be equal to our prediction minus whether they survived squared. So this is going to be our squared error. There they all are, our squared errors. And so here I've just summed them up. I could have taken the mean. I guess that would have been a bit easier to think about, but some is going to be given the same result. So here's our loss. And so now we need to optimize that using gradient descent. So Microsoft Excel has a gradient descent optimizer in it called solver. So I click solver, and it will say, okay, what do you try not to optimize? It's this one here, and I'm trying to do it by changing these cells here. And I'm trying to minimize it. And so we're starting a loss of 55.78. Actually, let's change it to mean as well. It would mean on average. We average. All right, so start at 1.03. So optimize that. And there we go. So it's gone from 1.03 to 0.1. And so we can check the predictions. So the first one, they predicted exactly correctly. It was, they didn't survive and we predicted wouldn't survive. Did I for this one? It's very close. And you can start to see, so this one, you can start to see a few issues here, which is like sometimes it's predicting less than one. So it's less than 0, and sometimes it's predicting more than one. Wouldn't it be cool if we had some way of constraining it to between 0 and 1? And that's an example of some of the things we're going to learn about that make this stuff work a little bit better. But you can see it's doing an okay job. So this is not deep learning. This is not a neural net yet. This is just a regression. So to make it into a neural net, we need to do it multiple times. So I'm just going to do it twice. So now rather than one set of coefficients, I've got two cents. And again, I just put in random numbers. Other than that, all the data is the same. And so now I'm going to have my sum product again. So the first sum product is with my first set of coefficients. And my second sum product is with my second set of coefficients. So I'm just calling them linear one and linear two. Now there's no point adding those up together because if you add up two linear functions together, you get another linear function. We want to get all those wiggles, right? So that's why we have to do our round view. So in Microsoft Excel, a round view looks like this. If the number is less than 0, do 0, otherwise use the number. So that's how we're going to replace the negatives with 0s. And then finally, if you remember from our spreadsheet, we have to add them together. So we add the values together. So that's going to be our prediction. And then our loss is the same as the other sheet. It's just survived minus prediction squared. And let's change that to main average. Okay. So let's try solving that. Optimize, A H 1. And this time we're changing all of those. So this is using gradient descent. Excel Solvers is not the fastest thing for it, but it gets the job done. Okay. Let's see how we went. 0.08 for our deep learning model versus 0.1 for our regression. So it's a bit better. So there you go. So we've now created our first deep learning neural network from scratch. And we did it in Microsoft Excel. Everybody's favorite artificial intelligence tool. So that was a bit slow and painful. Be a bit faster and easier if we used matrix modification. So let's finally do that. So this next one is going to be exactly the same as the last one, but with matrix modification. So all our data looks the same. You'll notice the key difference now is our parameters have been transposed. So before I had the parameters matching the data in terms of being in columns. For matrix modification, the expectation is that when matrix modification works, it has to transpose. This goes the x and y is kind of the opposite way around, the rows and columns of the opposite way around. Other than that, it's the same. I've got the same. I just copied and pasted the random numbers. So we had exactly the same starting point. And so now our entire, this entire thing here is a single function, which is matrix multiply all of this by all of this. And so when I run that, it fills in exactly the same numbers. Make this average. And so now we can optimize that. Like that, a minimum, changing these. Solve. It should get the same number. Point away, wasn't it? Yep, and we do. Okay. So that's just another way of doing the same thing. So you can see that matrix modification, it takes like a surprisingly long time, at least for me, to get an intuitive feel for matrix modification is like a single mathematical operation. So I still find it helpful to kind of remind myself, it's just doing these sum products and additions. Okay, so that is a deep learning neural network in Microsoft Excel. And the Titanic Kaggle competition, by the way, is a pretty fun learning competition. If you haven't done much machine learning before, then it's certainly worth trying out just to get the feel for these, how these all get put together. So the chapter of the book that this lesson goes with is chapter four. And chapter four of the book is the chapter where we lose the most people, because it's to be honest, it's hard. Now part of the reason it's hard is I couldn't put this into a book. So we're teaching it a very different way in the course, to what's in the book. And you can use the two together, but if you've tried to read the book and been a bit disheartened, try following through this spreadsheet instead. Maybe try, like if you use numbers or Google Sheets or something, you can try to create your own kind of version of it, how much of a spreadsheet platform you prefer, or you could try to do it yourself from scratch and Python, you know, if you want to really test yourself. So there's some suggestions. Okay. Question from Victor Guerra. And the Excel exercise, when Jeremy is doing some feature engineering, he comes up with two new columns, P class one and P class two. That is true. P class one and P class two. Why is there no P class three column? Is it because P class one, if P class one is zero and P class two is zero, then P class three must be one. So in a way, two columns are enough to encode the original column. Yes. That's exactly the reason. So there's no need to tell the computer about things that can kind of figure out for itself. So when you create, these are called dummy variables. So when you create dummy variables for a categorical variable with three levels, that's this one, you need two dummy variables. So in general, categorical variable with n levels needs n minus one columns. Thanks for the good question. So what we're going to be doing in our next lesson is looking at natural language processing. So so far, we've looked at some computer vision and just now we've looked at some what we call tabular data, so kind of spreadsheet type data. Next up, we're going to be looking at natural language processing. So I'll give you a taste of it so you might want to open up the getting started with the NLP for absolute beginners notebook. So here's the getting started with the NLP for absolute beginners notebook. I will say as a notebook author, I may sound a bit lame, but I always see when people have voted it, it always makes me really happy. So and it also helps other people find it. So remember to upload these notebooks or any other notebooks you like. I also always read all the comments. So if you want to ask any questions or make any comments, I enjoy those as well. So natural language processing is about rather than taking, for example, image data and making predictions, we take text data. Most of the time is in the form of prose, so plain English text. So English is the most common language used for NLP, but there's NLP models in dozens of different languages nowadays. And if you're a non English speaker, you'll find that for many languages, there's less resources in non English languages and there's a great opportunity to provide NLP resources in your language. This has actually been one of the things that the fast AI community has been fantastic at in the global community is building NLP resources. For example, the first Farsi NLP resource was created by a student from the very first Farsi course, the Indic languages, some of the best resources have come out of Farsi alumni and so forth. So that's a particularly valuable thing you could look at. So if your language is not well represented, that's an opportunity, not a problem. So some examples of things you could use NLP for, well, perhaps the most common and practically useful in my opinion is classification. Classification means you take a document. Now when I say a document, that could be one or two words. It could be a book, it could be a Wikipedia page, so it could be any length. With user word document, it sounds like that's a specific kind of length, but it can be a very short thing, a very long thing. We take a document and we try to figure out a category for it. Now that can cover many, many different kinds of applications. So one common one that we'll look at a bit is sentiment analysis. So for example, is this movie review positive or negative sentiment analysis is very helpful in things like marketing and product development. In big companies, there's lots and lots of information coming in about your product. It's very nice to be able to quickly sort it out and to track metrics from week to week. Something like figuring out what author wrote the document would be an example of a classification exercise because you're trying to put it a category in this case is which author. Here's a lot of opportunity and legal discovery. There's already some products in this area where in this case the category is this legal document in scope or out of scope in the court case. Just organizing documents, triaging inbound emails. So which part of the organization should it be sent to? Was it urgent or not? How much stuff like that? So these are examples of classification. What you'll find is when we look at classification tasks in NLP, it's going to look very, very similar to images. But what we're going to do is we're going to use a different library. The library we're going to use is called hugging first transformers rather than fast DA. And there's two reasons for that. The main reason why is because I think it's really helpful to see how things are done in more than one library. And hugging first transformers, so first DA has a very layered architecture. So you can do things at a very high level with very little code. Or you can dig deeper and deeper and deeper getting more and more fine correct. Hacking first transformers doesn't have the same high level API at all that fast DA has. So you have to do more stuff manually. And so at this point of the course, we're going to actually intentionally use a library which is a little bit less user friendly in order to see kind of what extra steps you have to go through to use other libraries. Having said that, the reason I picked this particular library is it is particularly good. It has really good models in it. It has a lot of really good techniques in it. Not at all surprising because they have hired lots and lots of fast AI alumni. So they have very high quality people working on it. So before the next lesson, yeah, if you've got time, take a look at this notebook and take a look at the data. The data we're going to be working with is quite interesting. It's from a Kaggle competition which is trying to figure out in patterns whether two concepts are referring to the same thing or not, whether those concepts are represented as English text. And when you think about it, that is a classification task because the document is basically text one, blah, text two, blah, and then the category is similar or not similar. And in fact, in this case, they actually have scores. It's either going to be basically 0, 0.25, 0.5, 0.751, or how similar is it? But it's basically a classification task when you think of it that way. So yeah, you can have a look at the data. And next week, we're going to go through, step by step through this notebook. And we're going to take advantage of that as an opportunity also to talk about the really important topics of validation sets and metrics, which are two of the most important topics in not just deep learning, but machine learning more generally. All right, thanks everybody. I'll see you next week. Bye.
